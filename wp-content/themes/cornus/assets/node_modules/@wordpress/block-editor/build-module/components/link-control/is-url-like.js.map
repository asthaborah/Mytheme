{"version":3,"names":["getProtocol","isValidProtocol","isValidFragment","isURLLike","val","hasSpaces","includes","protocol","protocolIsValid","mayBeTLD","hasPossibleTLD","isWWW","startsWith","isInternal","url","maxLength","cleanedURL","split","regex","RegExp","test"],"sources":["@wordpress/block-editor/src/components/link-control/is-url-like.js"],"sourcesContent":["/**\n * WordPress dependencies\n */\nimport { getProtocol, isValidProtocol, isValidFragment } from '@wordpress/url';\n\n/**\n * Determines whether a given value could be a URL. Note this does not\n * guarantee the value is a URL only that it looks like it might be one. For\n * example, just because a string has `www.` in it doesn't make it a URL,\n * but it does make it highly likely that it will be so in the context of\n * creating a link it makes sense to treat it like one.\n *\n * @param {string} val the candidate for being URL-like (or not).\n *\n * @return {boolean} whether or not the value is potentially a URL.\n */\nexport default function isURLLike( val ) {\n\tconst hasSpaces = val.includes( ' ' );\n\n\tif ( hasSpaces ) {\n\t\treturn false;\n\t}\n\n\tconst protocol = getProtocol( val );\n\tconst protocolIsValid = isValidProtocol( protocol );\n\n\tconst mayBeTLD = hasPossibleTLD( val );\n\n\tconst isWWW = val?.startsWith( 'www.' );\n\n\tconst isInternal = val?.startsWith( '#' ) && isValidFragment( val );\n\n\treturn protocolIsValid || isWWW || isInternal || mayBeTLD;\n}\n\n/**\n * Checks if a given URL has a valid Top-Level Domain (TLD).\n *\n * @param {string} url       - The URL to check.\n * @param {number} maxLength - The maximum length of the TLD.\n * @return {boolean} Returns true if the URL has a valid TLD, false otherwise.\n */\nfunction hasPossibleTLD( url, maxLength = 6 ) {\n\t// Clean the URL by removing anything after the first occurrence of \"?\" or \"#\".\n\tconst cleanedURL = url.split( /[?#]/ )[ 0 ];\n\n\t// Regular expression explanation:\n\t// - (?<=\\S)                  : Positive lookbehind assertion to ensure there is at least one non-whitespace character before the TLD\n\t// - \\.                       : Matches a literal dot (.)\n\t// - [a-zA-Z_]{2,maxLength}   : Matches 2 to maxLength letters or underscores, representing the TLD\n\t// - (?:\\/|$)                 : Non-capturing group that matches either a forward slash (/) or the end of the string\n\tconst regex = new RegExp(\n\t\t`(?<=\\\\S)\\\\.(?:[a-zA-Z_]{2,${ maxLength }})(?:\\\\/|$)`\n\t);\n\n\treturn regex.test( cleanedURL );\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,WAAW,EAAEC,eAAe,EAAEC,eAAe,QAAQ,gBAAgB;;AAE9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,SAASA,CAAEC,GAAG,EAAG;EACxC,MAAMC,SAAS,GAAGD,GAAG,CAACE,QAAQ,CAAE,GAAI,CAAC;EAErC,IAAKD,SAAS,EAAG;IAChB,OAAO,KAAK;EACb;EAEA,MAAME,QAAQ,GAAGP,WAAW,CAAEI,GAAI,CAAC;EACnC,MAAMI,eAAe,GAAGP,eAAe,CAAEM,QAAS,CAAC;EAEnD,MAAME,QAAQ,GAAGC,cAAc,CAAEN,GAAI,CAAC;EAEtC,MAAMO,KAAK,GAAGP,GAAG,EAAEQ,UAAU,CAAE,MAAO,CAAC;EAEvC,MAAMC,UAAU,GAAGT,GAAG,EAAEQ,UAAU,CAAE,GAAI,CAAC,IAAIV,eAAe,CAAEE,GAAI,CAAC;EAEnE,OAAOI,eAAe,IAAIG,KAAK,IAAIE,UAAU,IAAIJ,QAAQ;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,cAAcA,CAAEI,GAAG,EAAEC,SAAS,GAAG,CAAC,EAAG;EAC7C;EACA,MAAMC,UAAU,GAAGF,GAAG,CAACG,KAAK,CAAE,MAAO,CAAC,CAAE,CAAC,CAAE;;EAE3C;EACA;EACA;EACA;EACA;EACA,MAAMC,KAAK,GAAG,IAAIC,MAAM,CACtB,6BAA6BJ,SAAW,aAC1C,CAAC;EAED,OAAOG,KAAK,CAACE,IAAI,CAAEJ,UAAW,CAAC;AAChC"}