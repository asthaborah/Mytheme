"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = BorderPanel;
exports.useHasBorderPanel = useHasBorderPanel;
exports.useHasBorderPanelControls = useHasBorderPanelControls;
var _react = require("react");
var _components = require("@wordpress/components");
var _element = require("@wordpress/element");
var _i18n = require("@wordpress/i18n");
var _borderRadiusControl = _interopRequireDefault(require("../border-radius-control"));
var _hooks = require("./hooks");
var _utils = require("./utils");
var _getBlockSettings = require("../../store/get-block-settings");
var _object = require("../../utils/object");
var _border = require("../../hooks/border");
var _shadowPanelComponents = require("./shadow-panel-components");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

function useHasBorderPanel(settings) {
  const controls = Object.values(useHasBorderPanelControls(settings));
  return controls.some(Boolean);
}
function useHasBorderPanelControls(settings) {
  const controls = {
    hasBorderColor: useHasBorderColorControl(settings),
    hasBorderRadius: useHasBorderRadiusControl(settings),
    hasBorderStyle: useHasBorderStyleControl(settings),
    hasBorderWidth: useHasBorderWidthControl(settings),
    hasShadow: useHasShadowControl(settings)
  };
  return controls;
}
function useHasBorderColorControl(settings) {
  return settings?.border?.color;
}
function useHasBorderRadiusControl(settings) {
  return settings?.border?.radius;
}
function useHasBorderStyleControl(settings) {
  return settings?.border?.style;
}
function useHasBorderWidthControl(settings) {
  return settings?.border?.width;
}
function useHasShadowControl(settings) {
  const shadows = (0, _shadowPanelComponents.useShadowPresets)(settings);
  return !!settings?.shadow && shadows.length > 0;
}
function BorderToolsPanel({
  resetAllFilter,
  onChange,
  value,
  panelId,
  children,
  label
}) {
  const resetAll = () => {
    const updatedValue = resetAllFilter(value);
    onChange(updatedValue);
  };
  return (0, _react.createElement)(_components.__experimentalToolsPanel, {
    label: label,
    resetAll: resetAll,
    panelId: panelId,
    dropdownMenuProps: _utils.TOOLSPANEL_DROPDOWNMENU_PROPS
  }, children);
}
const DEFAULT_CONTROLS = {
  radius: true,
  color: true,
  width: true,
  shadow: false
};
function BorderPanel({
  as: Wrapper = BorderToolsPanel,
  value,
  onChange,
  inheritedValue = value,
  settings,
  panelId,
  name,
  defaultControls = DEFAULT_CONTROLS
}) {
  var _settings$shadow$pres, _overrideOrigins;
  const colors = (0, _hooks.useColorsPerOrigin)(settings);
  const decodeValue = (0, _element.useCallback)(rawValue => (0, _utils.getValueFromVariable)({
    settings
  }, '', rawValue), [settings]);
  const encodeColorValue = colorValue => {
    const allColors = colors.flatMap(({
      colors: originColors
    }) => originColors);
    const colorObject = allColors.find(({
      color
    }) => color === colorValue);
    return colorObject ? 'var:preset|color|' + colorObject.slug : colorValue;
  };
  const border = (0, _element.useMemo)(() => {
    if ((0, _components.__experimentalHasSplitBorders)(inheritedValue?.border)) {
      const borderValue = {
        ...inheritedValue?.border
      };
      ['top', 'right', 'bottom', 'left'].forEach(side => {
        borderValue[side] = {
          ...borderValue[side],
          color: decodeValue(borderValue[side]?.color)
        };
      });
      return borderValue;
    }
    return {
      ...inheritedValue?.border,
      color: inheritedValue?.border?.color ? decodeValue(inheritedValue?.border?.color) : undefined
    };
  }, [inheritedValue?.border, decodeValue]);
  const setBorder = newBorder => onChange({
    ...value,
    border: newBorder
  });
  const showBorderColor = useHasBorderColorControl(settings);
  const showBorderStyle = useHasBorderStyleControl(settings);
  const showBorderWidth = useHasBorderWidthControl(settings);

  // Border radius.
  const showBorderRadius = useHasBorderRadiusControl(settings);
  const borderRadiusValues = decodeValue(border?.radius);
  const setBorderRadius = newBorderRadius => setBorder({
    ...border,
    radius: newBorderRadius
  });
  const hasBorderRadius = () => {
    const borderValues = value?.border?.radius;
    if (typeof borderValues === 'object') {
      return Object.entries(borderValues).some(Boolean);
    }
    return !!borderValues;
  };
  const hasShadowControl = useHasShadowControl(settings);

  // Shadow
  const shadow = decodeValue(inheritedValue?.shadow);
  const shadowPresets = (_settings$shadow$pres = settings?.shadow?.presets) !== null && _settings$shadow$pres !== void 0 ? _settings$shadow$pres : {};
  const overriddenShadowPresets = (_overrideOrigins = (0, _getBlockSettings.overrideOrigins)(shadowPresets)) !== null && _overrideOrigins !== void 0 ? _overrideOrigins : [];
  const setShadow = newValue => {
    const slug = overriddenShadowPresets?.find(({
      shadow: shadowName
    }) => shadowName === newValue)?.slug;
    onChange((0, _object.setImmutably)(value, ['shadow'], slug ? `var:preset|shadow|${slug}` : newValue || undefined));
  };
  const hasShadow = () => !!value?.shadow;
  const resetShadow = () => setShadow(undefined);
  const resetBorder = () => {
    if (hasBorderRadius()) {
      return setBorder({
        radius: value?.border?.radius
      });
    }
    setBorder(undefined);
  };
  const onBorderChange = newBorder => {
    // Ensure we have a visible border style when a border width or
    // color is being selected.
    const updatedBorder = {
      ...newBorder
    };
    if ((0, _components.__experimentalHasSplitBorders)(updatedBorder)) {
      ['top', 'right', 'bottom', 'left'].forEach(side => {
        if (updatedBorder[side]) {
          updatedBorder[side] = {
            ...updatedBorder[side],
            color: encodeColorValue(updatedBorder[side]?.color)
          };
        }
      });
    } else if (updatedBorder) {
      updatedBorder.color = encodeColorValue(updatedBorder.color);
    }

    // As radius is maintained separately to color, style, and width
    // maintain its value. Undefined values here will be cleaned when
    // global styles are saved.
    setBorder({
      radius: border?.radius,
      ...updatedBorder
    });
  };
  const resetAllFilter = (0, _element.useCallback)(previousValue => {
    return {
      ...previousValue,
      border: undefined,
      shadow: undefined
    };
  }, []);
  const showBorderByDefault = defaultControls?.color || defaultControls?.width;
  const hasBorderControl = showBorderColor || showBorderStyle || showBorderWidth || showBorderRadius;
  const label = (0, _border.useBorderPanelLabel)({
    blockName: name,
    hasShadowControl,
    hasBorderControl
  });
  return (0, _react.createElement)(Wrapper, {
    resetAllFilter: resetAllFilter,
    value: value,
    onChange: onChange,
    panelId: panelId,
    label: label
  }, (showBorderWidth || showBorderColor) && (0, _react.createElement)(_components.__experimentalToolsPanelItem, {
    hasValue: () => (0, _components.__experimentalIsDefinedBorder)(value?.border),
    label: (0, _i18n.__)('Border'),
    onDeselect: () => resetBorder(),
    isShownByDefault: showBorderByDefault,
    panelId: panelId
  }, (0, _react.createElement)(_components.__experimentalBorderBoxControl, {
    colors: colors,
    enableAlpha: true,
    enableStyle: showBorderStyle,
    onChange: onBorderChange,
    popoverOffset: 40,
    popoverPlacement: "left-start",
    value: border,
    __experimentalIsRenderedInSidebar: true,
    size: '__unstable-large',
    hideLabelFromVision: !hasShadowControl,
    label: (0, _i18n.__)('Border')
  })), showBorderRadius && (0, _react.createElement)(_components.__experimentalToolsPanelItem, {
    hasValue: hasBorderRadius,
    label: (0, _i18n.__)('Radius'),
    onDeselect: () => setBorderRadius(undefined),
    isShownByDefault: defaultControls.radius,
    panelId: panelId
  }, (0, _react.createElement)(_borderRadiusControl.default, {
    values: borderRadiusValues,
    onChange: newValue => {
      setBorderRadius(newValue || undefined);
    }
  })), hasShadowControl && (0, _react.createElement)(_components.__experimentalToolsPanelItem, {
    label: (0, _i18n.__)('Shadow'),
    hasValue: hasShadow,
    onDeselect: resetShadow,
    isShownByDefault: defaultControls.shadow,
    panelId: panelId
  }, hasBorderControl ? (0, _react.createElement)(_components.BaseControl.VisualLabel, {
    as: "legend"
  }, (0, _i18n.__)('Shadow')) : null, (0, _react.createElement)(_components.__experimentalItemGroup, {
    isBordered: true,
    isSeparated: true
  }, (0, _react.createElement)(_shadowPanelComponents.ShadowPopover, {
    shadow: shadow,
    onShadowChange: setShadow,
    settings: settings
  }))));
}
//# sourceMappingURL=border-panel.js.map