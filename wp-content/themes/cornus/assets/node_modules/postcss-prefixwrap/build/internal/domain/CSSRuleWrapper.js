"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prefixWrapCSSSelector = exports.prefixWrapCSSRule = void 0;
const CSSSelector_1 = require("./CSSSelector");
const prefixWrapCSSRule = (cssRule, nested, ignoredSelectors, prefixSelector, prefixRootTags) => {
    // Check each rule to see if it exactly matches our prefix selector, when
    // this happens, don't try to prefix that selector.
    const rules = cssRule.selector
        .split(",")
        .filter((selector) => !(0, CSSSelector_1.cssRuleMatchesPrefixSelector)({ selector: selector }, prefixSelector));
    if (rules.length === 0) {
        return;
    }
    cssRule.selector = rules
        .map((cssSelector) => (0, exports.prefixWrapCSSSelector)(cssSelector, cssRule, nested, ignoredSelectors, prefixSelector, prefixRootTags))
        .filter(CSSSelector_1.isValidCSSSelector)
        .join(", ");
};
exports.prefixWrapCSSRule = prefixWrapCSSRule;
const prefixWrapCSSSelector = (cssSelector, cssRule, nested, ignoredSelectors, prefixSelector, prefixRootTags) => {
    const cleanedSelector = (0, CSSSelector_1.cleanSelector)(cssSelector);
    if (cleanedSelector === "") {
        return null;
    }
    // Don't prefix nested selected.
    if (nested !== null && cleanedSelector.startsWith(nested, 0)) {
        return cleanedSelector;
    }
    // Do not prefix keyframes rules.
    if ((0, CSSSelector_1.isKeyframes)(cssRule)) {
        return cleanedSelector;
    }
    // Check for matching ignored selectors
    if (ignoredSelectors.some((currentValue) => cleanedSelector.match(currentValue))) {
        return cleanedSelector;
    }
    // Anything other than a root tag is always prefixed.
    if ((0, CSSSelector_1.isNotRootTag)(cleanedSelector)) {
        return prefixSelector + " " + cleanedSelector;
    }
    // Handle special case where root tags should be converted into classes
    // rather than being replaced.
    if (prefixRootTags) {
        return prefixSelector + " ." + cleanedSelector;
    }
    // HTML and Body elements cannot be contained within our container so lets
    // extract their styles.
    return cleanedSelector.replace(/^(body|html|:root)/, prefixSelector);
};
exports.prefixWrapCSSSelector = prefixWrapCSSSelector;
