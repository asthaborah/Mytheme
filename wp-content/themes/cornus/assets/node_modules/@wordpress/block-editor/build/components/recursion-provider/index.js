"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DeprecatedExperimentalUseHasRecursion = exports.DeprecatedExperimentalRecursionProvider = void 0;
exports.RecursionProvider = RecursionProvider;
exports.useHasRecursion = useHasRecursion;
var _react = require("react");
var _element = require("@wordpress/element");
var _deprecated = _interopRequireDefault(require("@wordpress/deprecated"));
var _context = require("../block-edit/context");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const RenderedRefsContext = (0, _element.createContext)({});

/**
 * Immutably adds an unique identifier to a set scoped for a given block type.
 *
 * @param {Object} renderedBlocks Rendered blocks grouped by block name
 * @param {string} blockName      Name of the block.
 * @param {*}      uniqueId       Any value that acts as a unique identifier for a block instance.
 *
 * @return {Object} The list of rendered blocks grouped by block name.
 */
function addToBlockType(renderedBlocks, blockName, uniqueId) {
  const result = {
    ...renderedBlocks,
    [blockName]: renderedBlocks[blockName] ? new Set(renderedBlocks[blockName]) : new Set()
  };
  result[blockName].add(uniqueId);
  return result;
}

/**
 * A React context provider for use with the `useHasRecursion` hook to prevent recursive
 * renders.
 *
 * Wrap block content with this provider and provide the same `uniqueId` prop as used
 * with `useHasRecursion`.
 *
 * @param {Object}      props
 * @param {*}           props.uniqueId  Any value that acts as a unique identifier for a block instance.
 * @param {string}      props.blockName Optional block name.
 * @param {JSX.Element} props.children  React children.
 *
 * @return {JSX.Element} A React element.
 */
function RecursionProvider({
  children,
  uniqueId,
  blockName = ''
}) {
  const previouslyRenderedBlocks = (0, _element.useContext)(RenderedRefsContext);
  const {
    name
  } = (0, _context.useBlockEditContext)();
  blockName = blockName || name;
  const newRenderedBlocks = (0, _element.useMemo)(() => addToBlockType(previouslyRenderedBlocks, blockName, uniqueId), [previouslyRenderedBlocks, blockName, uniqueId]);
  return (0, _react.createElement)(RenderedRefsContext.Provider, {
    value: newRenderedBlocks
  }, children);
}

/**
 * A React hook for keeping track of blocks previously rendered up in the block
 * tree. Blocks susceptible to recursion can use this hook in their `Edit`
 * function to prevent said recursion.
 *
 * Use this with the `RecursionProvider` component, using the same `uniqueId` value
 * for both the hook and the provider.
 *
 * @param {*}      uniqueId  Any value that acts as a unique identifier for a block instance.
 * @param {string} blockName Optional block name.
 *
 * @return {boolean} A boolean describing whether the provided id has already been rendered.
 */
function useHasRecursion(uniqueId, blockName = '') {
  const previouslyRenderedBlocks = (0, _element.useContext)(RenderedRefsContext);
  const {
    name
  } = (0, _context.useBlockEditContext)();
  blockName = blockName || name;
  return Boolean(previouslyRenderedBlocks[blockName]?.has(uniqueId));
}
const DeprecatedExperimentalRecursionProvider = props => {
  (0, _deprecated.default)('wp.blockEditor.__experimentalRecursionProvider', {
    since: '6.5',
    alternative: 'wp.blockEditor.RecursionProvider'
  });
  return (0, _react.createElement)(RecursionProvider, {
    ...props
  });
};
exports.DeprecatedExperimentalRecursionProvider = DeprecatedExperimentalRecursionProvider;
const DeprecatedExperimentalUseHasRecursion = props => {
  (0, _deprecated.default)('wp.blockEditor.__experimentalUseHasRecursion', {
    since: '6.5',
    alternative: 'wp.blockEditor.useHasRecursion'
  });
  return useHasRecursion(...props);
};
exports.DeprecatedExperimentalUseHasRecursion = DeprecatedExperimentalUseHasRecursion;
//# sourceMappingURL=index.js.map