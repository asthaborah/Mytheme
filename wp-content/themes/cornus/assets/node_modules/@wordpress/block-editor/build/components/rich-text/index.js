"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PrivateRichText = void 0;
Object.defineProperty(exports, "RichTextShortcut", {
  enumerable: true,
  get: function () {
    return _shortcut.RichTextShortcut;
  }
});
Object.defineProperty(exports, "RichTextToolbarButton", {
  enumerable: true,
  get: function () {
    return _toolbarButton.RichTextToolbarButton;
  }
});
exports.RichTextWrapper = RichTextWrapper;
Object.defineProperty(exports, "__unstableRichTextInputEvent", {
  enumerable: true,
  get: function () {
    return _inputEvent.__unstableRichTextInputEvent;
  }
});
exports.keyboardShortcutContext = exports.inputEventContext = exports.default = void 0;
var _react = require("react");
var _classnames = _interopRequireDefault(require("classnames"));
var _element = require("@wordpress/element");
var _data = require("@wordpress/data");
var _compose = require("@wordpress/compose");
var _richText = require("@wordpress/rich-text");
var _components = require("@wordpress/components");
var _blocks = require("@wordpress/blocks");
var _autocomplete = require("../autocomplete");
var _blockEdit = require("../block-edit");
var _context = require("../block-edit/context");
var _formatToolbarContainer = _interopRequireDefault(require("./format-toolbar-container"));
var _store = require("../../store");
var _useUndoAutomaticChange = require("./use-undo-automatic-change");
var _useMarkPersistent = require("./use-mark-persistent");
var _usePasteHandler = require("./use-paste-handler");
var _useBeforeInputRules = require("./use-before-input-rules");
var _useInputRules = require("./use-input-rules");
var _useDelete = require("./use-delete");
var _useEnter = require("./use-enter");
var _useFormatTypes = require("./use-format-types");
var _useRemoveBrowserShortcuts = require("./use-remove-browser-shortcuts");
var _useShortcuts = require("./use-shortcuts");
var _useInputEvents = require("./use-input-events");
var _useInsertReplacementText = require("./use-insert-replacement-text");
var _useFirefoxCompat = require("./use-firefox-compat");
var _formatEdit = _interopRequireDefault(require("./format-edit"));
var _utils = require("./utils");
var _content = require("./content");
var _withDeprecations = require("./with-deprecations");
var _lockUnlock = require("../../lock-unlock");
var _useBindingsAttributes = require("../../hooks/use-bindings-attributes");
var _shortcut = require("./shortcut");
var _toolbarButton = require("./toolbar-button");
var _inputEvent = require("./input-event");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const keyboardShortcutContext = exports.keyboardShortcutContext = (0, _element.createContext)();
const inputEventContext = exports.inputEventContext = (0, _element.createContext)();

/**
 * Removes props used for the native version of RichText so that they are not
 * passed to the DOM element and log warnings.
 *
 * @param {Object} props Props to filter.
 *
 * @return {Object} Filtered props.
 */
function removeNativeProps(props) {
  const {
    __unstableMobileNoFocusOnMount,
    deleteEnter,
    placeholderTextColor,
    textAlign,
    selectionColor,
    tagsToEliminate,
    disableEditingMenu,
    fontSize,
    fontFamily,
    fontWeight,
    fontStyle,
    minWidth,
    maxWidth,
    setRef,
    disableSuggestions,
    disableAutocorrection,
    ...restProps
  } = props;
  return restProps;
}
function RichTextWrapper({
  children,
  tagName = 'div',
  value: adjustedValue = '',
  onChange: adjustedOnChange,
  isSelected: originalIsSelected,
  multiline,
  inlineToolbar,
  wrapperClassName,
  autocompleters,
  onReplace,
  placeholder,
  allowedFormats,
  withoutInteractiveFormatting,
  onRemove,
  onMerge,
  onSplit,
  __unstableOnSplitAtEnd: onSplitAtEnd,
  __unstableOnSplitAtDoubleLineEnd: onSplitAtDoubleLineEnd,
  identifier,
  preserveWhiteSpace,
  __unstablePastePlainText: pastePlainText,
  __unstableEmbedURLOnPaste,
  __unstableDisableFormats: disableFormats,
  disableLineBreaks,
  __unstableAllowPrefixTransformations,
  disableEditing,
  ...props
}, forwardedRef) {
  props = removeNativeProps(props);
  const anchorRef = (0, _element.useRef)();
  const context = (0, _blockEdit.useBlockEditContext)();
  const {
    clientId,
    isSelected: isBlockSelected,
    name: blockName
  } = context;
  const blockBindings = context[_context.blockBindingsKey];
  const selector = select => {
    // Avoid subscribing to the block editor store if the block is not
    // selected.
    if (!isBlockSelected) {
      return {
        isSelected: false
      };
    }
    const {
      getSelectionStart,
      getSelectionEnd
    } = select(_store.store);
    const selectionStart = getSelectionStart();
    const selectionEnd = getSelectionEnd();
    let isSelected;
    if (originalIsSelected === undefined) {
      isSelected = selectionStart.clientId === clientId && selectionEnd.clientId === clientId && selectionStart.attributeKey === identifier;
    } else if (originalIsSelected) {
      isSelected = selectionStart.clientId === clientId;
    }
    return {
      selectionStart: isSelected ? selectionStart.offset : undefined,
      selectionEnd: isSelected ? selectionEnd.offset : undefined,
      isSelected
    };
  };
  const {
    selectionStart,
    selectionEnd,
    isSelected
  } = (0, _data.useSelect)(selector, [clientId, identifier, originalIsSelected, isBlockSelected]);
  const disableBoundBlocks = (0, _data.useSelect)(select => {
    // Disable Rich Text editing if block bindings specify that.
    let _disableBoundBlocks = false;
    if (blockBindings && (0, _useBindingsAttributes.canBindBlock)(blockName)) {
      const blockTypeAttributes = (0, _blocks.getBlockType)(blockName).attributes;
      const {
        getBlockBindingsSource
      } = (0, _lockUnlock.unlock)(select(_blocks.store));
      for (const [attribute, args] of Object.entries(blockBindings)) {
        if (blockTypeAttributes?.[attribute]?.source !== 'rich-text') {
          break;
        }

        // If the source is not defined, or if its value of `lockAttributesEditing` is `true`, disable it.
        const blockBindingsSource = getBlockBindingsSource(args.source);
        if (!blockBindingsSource || blockBindingsSource.lockAttributesEditing) {
          _disableBoundBlocks = true;
          break;
        }
      }
    }
    return _disableBoundBlocks;
  }, [blockBindings, blockName]);
  const shouldDisableEditing = disableEditing || disableBoundBlocks;
  const {
    getSelectionStart,
    getSelectionEnd,
    getBlockRootClientId
  } = (0, _data.useSelect)(_store.store);
  const {
    selectionChange
  } = (0, _data.useDispatch)(_store.store);
  const adjustedAllowedFormats = (0, _utils.getAllowedFormats)({
    allowedFormats,
    disableFormats
  });
  const hasFormats = !adjustedAllowedFormats || adjustedAllowedFormats.length > 0;
  const onSelectionChange = (0, _element.useCallback)((start, end) => {
    const selection = {};
    const unset = start === undefined && end === undefined;
    if (typeof start === 'number' || unset) {
      // If we are only setting the start (or the end below), which
      // means a partial selection, and we're not updating a selection
      // with the same client ID, abort. This means the selected block
      // is a parent block.
      if (end === undefined && getBlockRootClientId(clientId) !== getBlockRootClientId(getSelectionEnd().clientId)) {
        return;
      }
      selection.start = {
        clientId,
        attributeKey: identifier,
        offset: start
      };
    }
    if (typeof end === 'number' || unset) {
      if (start === undefined && getBlockRootClientId(clientId) !== getBlockRootClientId(getSelectionStart().clientId)) {
        return;
      }
      selection.end = {
        clientId,
        attributeKey: identifier,
        offset: end
      };
    }
    selectionChange(selection);
  }, [clientId, identifier]);
  const {
    formatTypes,
    prepareHandlers,
    valueHandlers,
    changeHandlers,
    dependencies
  } = (0, _useFormatTypes.useFormatTypes)({
    clientId,
    identifier,
    withoutInteractiveFormatting,
    allowedFormats: adjustedAllowedFormats
  });
  function addEditorOnlyFormats(value) {
    return valueHandlers.reduce((accumulator, fn) => fn(accumulator, value.text), value.formats);
  }
  function removeEditorOnlyFormats(value) {
    formatTypes.forEach(formatType => {
      // Remove formats created by prepareEditableTree, because they are editor only.
      if (formatType.__experimentalCreatePrepareEditableTree) {
        value = (0, _richText.removeFormat)(value, formatType.name, 0, value.text.length);
      }
    });
    return value.formats;
  }
  function addInvisibleFormats(value) {
    return prepareHandlers.reduce((accumulator, fn) => fn(accumulator, value.text), value.formats);
  }
  const {
    value,
    getValue,
    onChange,
    ref: richTextRef
  } = (0, _richText.__unstableUseRichText)({
    value: adjustedValue,
    onChange(html, {
      __unstableFormats,
      __unstableText
    }) {
      adjustedOnChange(html);
      Object.values(changeHandlers).forEach(changeHandler => {
        changeHandler(__unstableFormats, __unstableText);
      });
    },
    selectionStart,
    selectionEnd,
    onSelectionChange,
    placeholder,
    __unstableIsSelected: isSelected,
    __unstableDisableFormats: disableFormats,
    preserveWhiteSpace,
    __unstableDependencies: [...dependencies, tagName],
    __unstableAfterParse: addEditorOnlyFormats,
    __unstableBeforeSerialize: removeEditorOnlyFormats,
    __unstableAddInvisibleFormats: addInvisibleFormats
  });
  const autocompleteProps = (0, _autocomplete.useBlockEditorAutocompleteProps)({
    onReplace,
    completers: autocompleters,
    record: value,
    onChange
  });
  (0, _useMarkPersistent.useMarkPersistent)({
    html: adjustedValue,
    value
  });
  const keyboardShortcuts = (0, _element.useRef)(new Set());
  const inputEvents = (0, _element.useRef)(new Set());
  function onFocus() {
    anchorRef.current?.focus();
  }
  const TagName = tagName;
  return (0, _react.createElement)(_react.Fragment, null, isSelected && (0, _react.createElement)(keyboardShortcutContext.Provider, {
    value: keyboardShortcuts
  }, (0, _react.createElement)(inputEventContext.Provider, {
    value: inputEvents
  }, (0, _react.createElement)(_components.Popover.__unstableSlotNameProvider, {
    value: "__unstable-block-tools-after"
  }, children && children({
    value,
    onChange,
    onFocus
  }), (0, _react.createElement)(_formatEdit.default, {
    value: value,
    onChange: onChange,
    onFocus: onFocus,
    formatTypes: formatTypes,
    forwardedRef: anchorRef
  })))), isSelected && hasFormats && (0, _react.createElement)(_formatToolbarContainer.default, {
    inline: inlineToolbar,
    editableContentElement: anchorRef.current
  }), (0, _react.createElement)(TagName
  // Overridable props.
  , {
    role: "textbox",
    "aria-multiline": !disableLineBreaks,
    "aria-label": placeholder,
    "aria-readonly": shouldDisableEditing,
    ...props,
    ...autocompleteProps,
    ref: (0, _compose.useMergeRefs)([
    // Rich text ref must be first because its focus listener
    // must be set up before any other ref calls .focus() on
    // mount.
    richTextRef, forwardedRef, autocompleteProps.ref, props.ref, (0, _useBeforeInputRules.useBeforeInputRules)({
      value,
      onChange
    }), (0, _useInputRules.useInputRules)({
      getValue,
      onChange,
      __unstableAllowPrefixTransformations,
      formatTypes,
      onReplace,
      selectionChange
    }), (0, _useInsertReplacementText.useInsertReplacementText)(), (0, _useRemoveBrowserShortcuts.useRemoveBrowserShortcuts)(), (0, _useShortcuts.useShortcuts)(keyboardShortcuts), (0, _useInputEvents.useInputEvents)(inputEvents), (0, _useUndoAutomaticChange.useUndoAutomaticChange)(), (0, _usePasteHandler.usePasteHandler)({
      isSelected,
      disableFormats,
      onChange,
      value,
      formatTypes,
      tagName,
      onReplace,
      onSplit,
      __unstableEmbedURLOnPaste,
      pastePlainText
    }), (0, _useDelete.useDelete)({
      value,
      onMerge,
      onRemove
    }), (0, _useEnter.useEnter)({
      removeEditorOnlyFormats,
      value,
      onReplace,
      onSplit,
      onChange,
      disableLineBreaks,
      onSplitAtEnd,
      onSplitAtDoubleLineEnd
    }), (0, _useFirefoxCompat.useFirefoxCompat)(), anchorRef]),
    contentEditable: !shouldDisableEditing,
    suppressContentEditableWarning: true,
    className: (0, _classnames.default)('block-editor-rich-text__editable', props.className, 'rich-text')
    // Setting tabIndex to 0 is unnecessary, the element is already
    // focusable because it's contentEditable. This also fixes a
    // Safari bug where it's not possible to Shift+Click multi
    // select blocks when Shift Clicking into an element with
    // tabIndex because Safari will focus the element. However,
    // Safari will correctly ignore nested contentEditable elements.
    ,
    tabIndex: props.tabIndex === 0 && !shouldDisableEditing ? null : props.tabIndex,
    "data-wp-block-attribute-key": identifier
  }));
}

// This is the private API for the RichText component.
// It allows access to all props, not just the public ones.
const PrivateRichText = exports.PrivateRichText = (0, _withDeprecations.withDeprecations)((0, _element.forwardRef)(RichTextWrapper));
PrivateRichText.Content = _content.Content;
PrivateRichText.isEmpty = value => {
  return !value || value.length === 0;
};

// This is the public API for the RichText component.
// We wrap the PrivateRichText component to hide some props from the public API.
/**
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/rich-text/README.md
 */
const PublicForwardedRichTextContainer = (0, _element.forwardRef)((props, ref) => {
  return (0, _react.createElement)(PrivateRichText, {
    ref: ref,
    ...props,
    disableEditing: false
  });
});
PublicForwardedRichTextContainer.Content = _content.Content;
PublicForwardedRichTextContainer.isEmpty = value => {
  return !value || value.length === 0;
};
var _default = exports.default = PublicForwardedRichTextContainer;
//# sourceMappingURL=index.js.map