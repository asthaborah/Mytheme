"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BlockPreview = BlockPreview;
exports.default = void 0;
exports.useBlockPreview = useBlockPreview;
var _react = require("react");
var _classnames = _interopRequireDefault(require("classnames"));
var _compose = require("@wordpress/compose");
var _data = require("@wordpress/data");
var _element = require("@wordpress/element");
var _deprecated = _interopRequireDefault(require("@wordpress/deprecated"));
var _provider = require("../provider");
var _auto = _interopRequireDefault(require("./auto"));
var _editorStyles = _interopRequireDefault(require("../editor-styles"));
var _store = require("../../store");
var _blockList = require("../block-list");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const EMPTY_ADDITIONAL_STYLES = [];
function BlockPreview({
  blocks,
  viewportWidth = 1200,
  minHeight,
  additionalStyles = EMPTY_ADDITIONAL_STYLES,
  // Deprecated props:
  __experimentalMinHeight,
  __experimentalPadding
}) {
  if (__experimentalMinHeight) {
    minHeight = __experimentalMinHeight;
    (0, _deprecated.default)('The __experimentalMinHeight prop', {
      since: '6.2',
      version: '6.4',
      alternative: 'minHeight'
    });
  }
  if (__experimentalPadding) {
    additionalStyles = [...additionalStyles, {
      css: `body { padding: ${__experimentalPadding}px; }`
    }];
    (0, _deprecated.default)('The __experimentalPadding prop of BlockPreview', {
      since: '6.2',
      version: '6.4',
      alternative: 'additionalStyles'
    });
  }
  const originalSettings = (0, _data.useSelect)(select => select(_store.store).getSettings(), []);
  const settings = (0, _element.useMemo)(() => ({
    ...originalSettings,
    focusMode: false,
    // Disable "Spotlight mode".
    __unstableIsPreviewMode: true
  }), [originalSettings]);
  const renderedBlocks = (0, _element.useMemo)(() => Array.isArray(blocks) ? blocks : [blocks], [blocks]);
  if (!blocks || blocks.length === 0) {
    return null;
  }
  return (0, _react.createElement)(_provider.ExperimentalBlockEditorProvider, {
    value: renderedBlocks,
    settings: settings
  }, (0, _react.createElement)(_auto.default, {
    viewportWidth: viewportWidth,
    minHeight: minHeight,
    additionalStyles: additionalStyles
  }));
}

/**
 * BlockPreview renders a preview of a block or array of blocks.
 *
 * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/block-editor/src/components/block-preview/README.md
 *
 * @param {Object}       preview               options for how the preview should be shown
 * @param {Array|Object} preview.blocks        A block instance (object) or an array of blocks to be previewed.
 * @param {number}       preview.viewportWidth Width of the preview container in pixels. Controls at what size the blocks will be rendered inside the preview. Default: 700.
 *
 * @return {Component} The component to be rendered.
 */
var _default = exports.default = (0, _element.memo)(BlockPreview);
/**
 * This hook is used to lightly mark an element as a block preview wrapper
 * element. Call this hook and pass the returned props to the element to mark as
 * a block preview wrapper, automatically rendering inner blocks as children. If
 * you define a ref for the element, it is important to pass the ref to this
 * hook, which the hook in turn will pass to the component through the props it
 * returns. Optionally, you can also pass any other props through this hook, and
 * they will be merged and returned.
 *
 * @param {Object}    options        Preview options.
 * @param {WPBlock[]} options.blocks Block objects.
 * @param {Object}    options.props  Optional. Props to pass to the element. Must contain
 *                                   the ref if one is defined.
 * @param {Object}    options.layout Layout settings to be used in the preview.
 */
function useBlockPreview({
  blocks,
  props = {},
  layout
}) {
  const originalSettings = (0, _data.useSelect)(select => select(_store.store).getSettings(), []);
  const settings = (0, _element.useMemo)(() => ({
    ...originalSettings,
    styles: undefined,
    // Clear styles included by the parent settings, as they are already output by the parent's EditorStyles.
    focusMode: false,
    // Disable "Spotlight mode".
    __unstableIsPreviewMode: true
  }), [originalSettings]);
  const disabledRef = (0, _compose.useDisabled)();
  const ref = (0, _compose.useMergeRefs)([props.ref, disabledRef]);
  const renderedBlocks = (0, _element.useMemo)(() => Array.isArray(blocks) ? blocks : [blocks], [blocks]);
  const children = (0, _react.createElement)(_provider.ExperimentalBlockEditorProvider, {
    value: renderedBlocks,
    settings: settings
  }, (0, _react.createElement)(_editorStyles.default, null), (0, _react.createElement)(_blockList.BlockListItems, {
    renderAppender: false,
    layout: layout
  }));
  return {
    ...props,
    ref,
    className: (0, _classnames.default)(props.className, 'block-editor-block-preview__live-content', 'components-disabled'),
    children: blocks?.length ? children : null
  };
}
//# sourceMappingURL=index.js.map