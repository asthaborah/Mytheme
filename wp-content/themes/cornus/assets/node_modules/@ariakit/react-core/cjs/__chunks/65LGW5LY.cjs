"use strict";Object.defineProperty(exports, "__esModule", {value: true});"use client";


var _XB3G2EO2cjs = require('./XB3G2EO2.cjs');


var _CVD2AZE2cjs = require('./CVD2AZE2.cjs');




var _RNZNGEL4cjs = require('./RNZNGEL4.cjs');




var _EO6LS72Hcjs = require('./EO6LS72H.cjs');


var _CJDHQUBRcjs = require('./CJDHQUBR.cjs');




var _AV6KTKLEcjs = require('./AV6KTKLE.cjs');

// src/portal/portal.tsx
var _react = require('react');
var _dom = require('@ariakit/core/utils/dom');
var _events = require('@ariakit/core/utils/events');





var _focus = require('@ariakit/core/utils/focus');
var _reactdom = require('react-dom');
var _jsxruntime = require('react/jsx-runtime');
function getRootElement(element) {
  return _dom.getDocument.call(void 0, element).body;
}
function getPortalElement(element, portalElement) {
  if (!portalElement) {
    return _dom.getDocument.call(void 0, element).createElement("div");
  }
  if (typeof portalElement === "function") {
    return portalElement(element);
  }
  return portalElement;
}
function getRandomId(prefix = "id") {
  return `${prefix ? `${prefix}-` : ""}${Math.random().toString(36).substr(2, 6)}`;
}
function queueFocus(element) {
  queueMicrotask(() => {
    element == null ? void 0 : element.focus();
  });
}
var usePortal = _RNZNGEL4cjs.createHook.call(void 0, 
  (_a) => {
    var _b = _a, {
      preserveTabOrder,
      preserveTabOrderAnchor,
      portalElement,
      portalRef,
      portal = true
    } = _b, props = _AV6KTKLEcjs.__objRest.call(void 0, _b, [
      "preserveTabOrder",
      "preserveTabOrderAnchor",
      "portalElement",
      "portalRef",
      "portal"
    ]);
    const ref = _react.useRef.call(void 0, null);
    const refProp = _EO6LS72Hcjs.useMergeRefs.call(void 0, ref, props.ref);
    const context = _react.useContext.call(void 0, _CVD2AZE2cjs.PortalContext);
    const [portalNode, setPortalNode] = _react.useState.call(void 0, null);
    const [anchorPortalNode, setAnchorPortalNode] = _react.useState.call(void 0, null);
    const outerBeforeRef = _react.useRef.call(void 0, null);
    const innerBeforeRef = _react.useRef.call(void 0, null);
    const innerAfterRef = _react.useRef.call(void 0, null);
    const outerAfterRef = _react.useRef.call(void 0, null);
    _EO6LS72Hcjs.useSafeLayoutEffect.call(void 0, () => {
      const element = ref.current;
      if (!element || !portal) {
        setPortalNode(null);
        return;
      }
      const portalEl = getPortalElement(element, portalElement);
      if (!portalEl) {
        setPortalNode(null);
        return;
      }
      const isPortalInDocument = portalEl.isConnected;
      if (!isPortalInDocument) {
        const rootElement = context || getRootElement(element);
        rootElement.appendChild(portalEl);
      }
      if (!portalEl.id) {
        portalEl.id = element.id ? `portal/${element.id}` : getRandomId();
      }
      setPortalNode(portalEl);
      _CJDHQUBRcjs.setRef.call(void 0, portalRef, portalEl);
      if (isPortalInDocument)
        return;
      return () => {
        portalEl.remove();
        _CJDHQUBRcjs.setRef.call(void 0, portalRef, null);
      };
    }, [portal, portalElement, context, portalRef]);
    _EO6LS72Hcjs.useSafeLayoutEffect.call(void 0, () => {
      if (!preserveTabOrder)
        return;
      if (!preserveTabOrderAnchor)
        return;
      const doc = _dom.getDocument.call(void 0, preserveTabOrderAnchor);
      const element = doc.createElement("span");
      element.style.position = "fixed";
      preserveTabOrderAnchor.insertAdjacentElement("afterend", element);
      setAnchorPortalNode(element);
      return () => {
        element.remove();
        setAnchorPortalNode(null);
      };
    }, [preserveTabOrder, preserveTabOrderAnchor]);
    _react.useEffect.call(void 0, () => {
      if (!portalNode)
        return;
      if (!preserveTabOrder)
        return;
      let raf = 0;
      const onFocus = (event) => {
        if (!_events.isFocusEventOutside.call(void 0, event))
          return;
        const focusing = event.type === "focusin";
        cancelAnimationFrame(raf);
        if (focusing) {
          return _focus.restoreFocusIn.call(void 0, portalNode);
        }
        raf = requestAnimationFrame(() => {
          _focus.disableFocusIn.call(void 0, portalNode, true);
        });
      };
      portalNode.addEventListener("focusin", onFocus, true);
      portalNode.addEventListener("focusout", onFocus, true);
      return () => {
        cancelAnimationFrame(raf);
        portalNode.removeEventListener("focusin", onFocus, true);
        portalNode.removeEventListener("focusout", onFocus, true);
      };
    }, [portalNode, preserveTabOrder]);
    props = _EO6LS72Hcjs.useWrapElement.call(void 0, 
      props,
      (element) => {
        element = // While the portal node is not in the DOM, we need to pass the
        // current context to the portal context, otherwise it's going to
        // reset to the body element on nested portals.
        /* @__PURE__ */ _jsxruntime.jsx.call(void 0, _CVD2AZE2cjs.PortalContext.Provider, { value: portalNode || context, children: element });
        if (!portal)
          return element;
        if (!portalNode) {
          return /* @__PURE__ */ _jsxruntime.jsx.call(void 0, 
            "span",
            {
              ref: refProp,
              id: props.id,
              style: { position: "fixed" },
              hidden: true
            }
          );
        }
        element = /* @__PURE__ */ _jsxruntime.jsxs.call(void 0, _jsxruntime.Fragment, { children: [
          preserveTabOrder && portalNode && /* @__PURE__ */ _jsxruntime.jsx.call(void 0, 
            _XB3G2EO2cjs.FocusTrap,
            {
              ref: innerBeforeRef,
              className: "__focus-trap-inner-before",
              onFocus: (event) => {
                if (_events.isFocusEventOutside.call(void 0, event, portalNode)) {
                  queueFocus(_focus.getNextTabbable.call(void 0, ));
                } else {
                  queueFocus(outerBeforeRef.current);
                }
              }
            }
          ),
          element,
          preserveTabOrder && portalNode && /* @__PURE__ */ _jsxruntime.jsx.call(void 0, 
            _XB3G2EO2cjs.FocusTrap,
            {
              ref: innerAfterRef,
              className: "__focus-trap-inner-after",
              onFocus: (event) => {
                if (_events.isFocusEventOutside.call(void 0, event, portalNode)) {
                  queueFocus(_focus.getPreviousTabbable.call(void 0, ));
                } else {
                  queueFocus(outerAfterRef.current);
                }
              }
            }
          )
        ] });
        if (portalNode) {
          element = _reactdom.createPortal.call(void 0, element, portalNode);
        }
        let preserveTabOrderElement = /* @__PURE__ */ _jsxruntime.jsxs.call(void 0, _jsxruntime.Fragment, { children: [
          preserveTabOrder && portalNode && /* @__PURE__ */ _jsxruntime.jsx.call(void 0, 
            _XB3G2EO2cjs.FocusTrap,
            {
              ref: outerBeforeRef,
              className: "__focus-trap-outer-before",
              onFocus: (event) => {
                const fromOuter = event.relatedTarget === outerAfterRef.current;
                if (!fromOuter && _events.isFocusEventOutside.call(void 0, event, portalNode)) {
                  queueFocus(innerBeforeRef.current);
                } else {
                  queueFocus(_focus.getPreviousTabbable.call(void 0, ));
                }
              }
            }
          ),
          preserveTabOrder && // We're using position: fixed here so that the browser doesn't
          // add margin to the element when setting gap on a parent element.
          /* @__PURE__ */ _jsxruntime.jsx.call(void 0, "span", { "aria-owns": portalNode == null ? void 0 : portalNode.id, style: { position: "fixed" } }),
          preserveTabOrder && portalNode && /* @__PURE__ */ _jsxruntime.jsx.call(void 0, 
            _XB3G2EO2cjs.FocusTrap,
            {
              ref: outerAfterRef,
              className: "__focus-trap-outer-after",
              onFocus: (event) => {
                if (_events.isFocusEventOutside.call(void 0, event, portalNode)) {
                  queueFocus(innerAfterRef.current);
                } else {
                  const nextTabbable = _focus.getNextTabbable.call(void 0, );
                  if (nextTabbable === innerBeforeRef.current) {
                    requestAnimationFrame(() => {
                      var _a2;
                      return (_a2 = _focus.getNextTabbable.call(void 0, )) == null ? void 0 : _a2.focus();
                    });
                    return;
                  }
                  queueFocus(nextTabbable);
                }
              }
            }
          )
        ] });
        if (anchorPortalNode && preserveTabOrder) {
          preserveTabOrderElement = _reactdom.createPortal.call(void 0, 
            preserveTabOrderElement,
            anchorPortalNode
          );
        }
        return /* @__PURE__ */ _jsxruntime.jsxs.call(void 0, _jsxruntime.Fragment, { children: [
          preserveTabOrderElement,
          element
        ] });
      },
      [
        portalNode,
        context,
        portal,
        props.id,
        preserveTabOrder,
        anchorPortalNode
      ]
    );
    props = _AV6KTKLEcjs.__spreadProps.call(void 0, _AV6KTKLEcjs.__spreadValues.call(void 0, {}, props), {
      ref: refProp
    });
    return props;
  }
);
var Portal = _RNZNGEL4cjs.createComponent.call(void 0, (props) => {
  const htmlProps = usePortal(props);
  return _RNZNGEL4cjs.createElement.call(void 0, "div", htmlProps);
});
if (process.env.NODE_ENV !== "production") {
  Portal.displayName = "Portal";
}




exports.usePortal = usePortal; exports.Portal = Portal;
