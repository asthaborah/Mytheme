import { createElement } from "react";
/**
 * Composite is a component that may contain navigable items represented by
 * CompositeItem. It's inspired by the WAI-ARIA Composite Role and implements
 * all the keyboard navigation mechanisms to ensure that there's only one
 * tab stop for the whole Composite element. This means that it can behave as
 * a roving tabindex or aria-activedescendant container.
 *
 * @see https://ariakit.org/components/composite
 */

/**
 * WordPress dependencies
 */
import { forwardRef } from '@wordpress/element';

/**
 * Internal dependencies
 */
import * as Current from '../current';
import { useInstanceId } from '@wordpress/compose';
function mapLegacyStatePropsToComponentProps(legacyProps) {
  // If a `state` prop is provided, we unpack that; otherwise,
  // the necessary props are provided directly in `legacyProps`.
  if (legacyProps.state) {
    const {
      state,
      ...rest
    } = legacyProps;
    const {
      store,
      ...props
    } = mapLegacyStatePropsToComponentProps(state);
    return {
      ...rest,
      ...props,
      store
    };
  }
  return legacyProps;
}
function proxyComposite(ProxiedComponent, propMap = {}) {
  const displayName = ProxiedComponent.displayName;
  const Component = legacyProps => {
    const {
      store,
      ...rest
    } = mapLegacyStatePropsToComponentProps(legacyProps);
    const props = rest;
    props.id = useInstanceId(store, props.baseId, props.id);
    Object.entries(propMap).forEach(([from, to]) => {
      if (props.hasOwnProperty(from)) {
        Object.assign(props, {
          [to]: props[from]
        });
        delete props[from];
      }
    });
    delete props.baseId;
    return createElement(ProxiedComponent, {
      ...props,
      store: store
    });
  };
  Component.displayName = displayName;
  return Component;
}

// The old `CompositeGroup` used to behave more like the current
// `CompositeRow`, but this has been split into two different
// components. We handle that difference by checking on the
// provided role, and returning the appropriate component.
const unproxiedCompositeGroup = forwardRef(({
  role,
  ...props
}, ref) => {
  const Component = role === 'row' ? Current.CompositeRow : Current.CompositeGroup;
  return createElement(Component, {
    ref: ref,
    role: role,
    ...props
  });
});
unproxiedCompositeGroup.displayName = 'CompositeGroup';
export const Composite = proxyComposite(Current.Composite, {
  baseId: 'id'
});
export const CompositeGroup = proxyComposite(unproxiedCompositeGroup);
export const CompositeItem = proxyComposite(Current.CompositeItem, {
  focusable: 'accessibleWhenDisabled'
});
export function useCompositeState(legacyStateOptions = {}) {
  const {
    baseId,
    currentId: defaultActiveId,
    orientation,
    rtl = false,
    loop: focusLoop = false,
    wrap: focusWrap = false,
    shift: focusShift = false,
    // eslint-disable-next-line camelcase
    unstable_virtual: virtualFocus
  } = legacyStateOptions;
  return {
    baseId: useInstanceId(Composite, 'composite', baseId),
    store: Current.useCompositeStore({
      defaultActiveId,
      rtl,
      orientation,
      focusLoop,
      focusShift,
      focusWrap,
      virtualFocus
    })
  };
}
//# sourceMappingURL=index.js.map