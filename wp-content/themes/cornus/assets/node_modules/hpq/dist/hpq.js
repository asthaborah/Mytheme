(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.hpq = {}));
})(this, (function (exports) { 'use strict';

	/**
	 * Given object and string of dot-delimited path segments, returns value at
	 * path or undefined if path cannot be resolved.
	 *
	 * @param object Lookup object
	 * @param path   Path to resolve
	 * @return       Resolved value
	 */
	function getPath(object, path) {
	  var segments = path.split('.');
	  var segment;
	  while (segment = segments.shift()) {
	    if (!(segment in object)) {
	      return;
	    }
	    object = object[segment];
	  }
	  return object;
	}

	/**
	 * Internal dependencies
	 */
	/**
	 * Function returning a DOM document created by `createHTMLDocument`. The same
	 * document is returned between invocations.
	 *
	 * @return DOM document.
	 */
	var getDocument = function () {
	  var doc;
	  return function () {
	    if (!doc) {
	      doc = document.implementation.createHTMLDocument('');
	    }
	    return doc;
	  };
	}();

	/**
	 * Given a markup string or DOM element, creates an object aligning with the
	 * shape of the matchers object, or the value returned by the matcher.
	 *
	 * @param source Source content
	 * @param matchers Matcher function or object of matchers
	 */

	/**
	 * Given a markup string or DOM element, creates an object aligning with the
	 * shape of the matchers object, or the value returned by the matcher.
	 *
	 * @param source Source content
	 * @param matchers Matcher function or object of matchers
	 */
	function parse(source, matchers) {
	  if (!matchers) {
	    return;
	  }

	  // Coerce to element
	  if ('string' === typeof source) {
	    var doc = getDocument();
	    doc.body.innerHTML = source;
	    source = doc.body;
	  }

	  // Return singular value
	  if (typeof matchers === 'function') {
	    return matchers(source);
	  }

	  // Bail if we can't handle matchers
	  if (Object !== matchers.constructor) {
	    return;
	  }

	  // Shape result by matcher object
	  return Object.keys(matchers).reduce(function (memo, key) {
	    var inner = matchers[key];
	    memo[key] = parse(source, inner);
	    return memo;
	  }, {});
	}

	/**
	 * Generates a function which matches node of type selector, returning an
	 * attribute by property if the attribute exists. If no selector is passed,
	 * returns property of the query element.
	 *
	 * @param name Property name
	 * @return Property value
	 */

	/**
	 * Generates a function which matches node of type selector, returning an
	 * attribute by property if the attribute exists. If no selector is passed,
	 * returns property of the query element.
	 *
	 * @param selector Optional selector
	 * @param name Property name
	 * @return Property value
	 */
	function prop(arg1, arg2) {
	  var name;
	  var selector;
	  if (1 === arguments.length) {
	    name = arg1;
	    selector = undefined;
	  } else {
	    name = arg2;
	    selector = arg1;
	  }
	  return function (node) {
	    var match = node;
	    if (selector) {
	      match = node.querySelector(selector);
	    }
	    if (match) {
	      return getPath(match, name);
	    }
	  };
	}

	/**
	 * Generates a function which matches node of type selector, returning an
	 * attribute by name if the attribute exists. If no selector is passed,
	 * returns attribute of the query element.
	 *
	 * @param name Attribute name
	 * @return Attribute value
	 */

	/**
	 * Generates a function which matches node of type selector, returning an
	 * attribute by name if the attribute exists. If no selector is passed,
	 * returns attribute of the query element.
	 *
	 * @param selector Optional selector
	 * @param name Attribute name
	 * @return Attribute value
	 */
	function attr(arg1, arg2) {
	  var name;
	  var selector;
	  if (1 === arguments.length) {
	    name = arg1;
	    selector = undefined;
	  } else {
	    name = arg2;
	    selector = arg1;
	  }
	  return function (node) {
	    var attributes = prop(selector, 'attributes')(node);
	    if (attributes && Object.prototype.hasOwnProperty.call(attributes, name)) {
	      return attributes[name].value;
	    }
	  };
	}

	/**
	 * Convenience for `prop( selector, 'innerHTML' )`.
	 *
	 * @see prop()
	 *
	 * @param selector Optional selector
	 * @return Inner HTML
	 */
	function html(selector) {
	  return prop(selector, 'innerHTML');
	}

	/**
	 * Convenience for `prop( selector, 'textContent' )`.
	 *
	 * @see prop()
	 *
	 * @param selector Optional selector
	 * @return Text content
	 */
	function text(selector) {
	  return prop(selector, 'textContent');
	}

	/**
	 * Creates a new matching context by first finding elements matching selector
	 * using querySelectorAll before then running another `parse` on `matchers`
	 * scoped to the matched elements.
	 *
	 * @see parse()
	 *
	 * @param selector Selector to match
	 * @param matchers Matcher function or object of matchers
	 * @return Matcher function which returns an array of matched value(s)
	 */
	function query(selector, matchers) {
	  return function (node) {
	    var matches = node.querySelectorAll(selector);
	    return [].map.call(matches, function (match) {
	      return parse(match, matchers);
	    });
	  };
	}

	exports.attr = attr;
	exports.html = html;
	exports.parse = parse;
	exports.prop = prop;
	exports.query = query;
	exports.text = text;

}));
