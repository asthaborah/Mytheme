"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.processBlockType = void 0;
var _isPlainObject = require("is-plain-object");
var _reactIs = require("react-is");
var _deprecated = _interopRequireDefault(require("@wordpress/deprecated"));
var _hooks = require("@wordpress/hooks");
var _utils = require("../api/utils");
var _constants = require("../api/constants");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/** @typedef {import('../api/registration').WPBlockType} WPBlockType */

const error = (...args) => window?.console?.error?.(...args);
const warn = (...args) => window?.console?.warn?.(...args);

/**
 * Mapping of legacy category slugs to their latest normal values, used to
 * accommodate updates of the default set of block categories.
 *
 * @type {Record<string,string>}
 */
const LEGACY_CATEGORY_MAPPING = {
  common: 'text',
  formatting: 'text',
  layout: 'design'
};

/**
 * Takes the unprocessed block type settings, merges them with block type metadata
 * and applies all the existing filters for the registered block type.
 * Next, it validates all the settings and performs additional processing to the block type definition.
 *
 * @param {string}      name          Block name.
 * @param {WPBlockType} blockSettings Unprocessed block type settings.
 *
 * @return {WPBlockType | undefined} The block, if it has been processed and can be registered; otherwise `undefined`.
 */
const processBlockType = (name, blockSettings) => ({
  select
}) => {
  const blockType = {
    name,
    icon: _constants.BLOCK_ICON_DEFAULT,
    keywords: [],
    attributes: {},
    providesContext: {},
    usesContext: [],
    selectors: {},
    supports: {},
    styles: [],
    variations: [],
    blockHooks: {},
    save: () => null,
    ...select.getBootstrappedBlockType(name),
    ...blockSettings
  };
  const settings = (0, _hooks.applyFilters)('blocks.registerBlockType', blockType, name, null);
  if (settings.description && typeof settings.description !== 'string') {
    (0, _deprecated.default)('Declaring non-string block descriptions', {
      since: '6.2'
    });
  }
  if (settings.deprecated) {
    settings.deprecated = settings.deprecated.map(deprecation => Object.fromEntries(Object.entries(
    // Only keep valid deprecation keys.
    (0, _hooks.applyFilters)('blocks.registerBlockType',
    // Merge deprecation keys with pre-filter settings
    // so that filters that depend on specific keys being
    // present don't fail.
    {
      // Omit deprecation keys here so that deprecations
      // can opt out of specific keys like "supports".
      ...(0, _utils.omit)(blockType, _constants.DEPRECATED_ENTRY_KEYS),
      ...deprecation
    }, blockType.name, deprecation)).filter(([key]) => _constants.DEPRECATED_ENTRY_KEYS.includes(key))));
  }
  if (!(0, _isPlainObject.isPlainObject)(settings)) {
    error('Block settings must be a valid object.');
    return;
  }
  if (typeof settings.save !== 'function') {
    error('The "save" property must be a valid function.');
    return;
  }
  if ('edit' in settings && !(0, _reactIs.isValidElementType)(settings.edit)) {
    error('The "edit" property must be a valid component.');
    return;
  }

  // Canonicalize legacy categories to equivalent fallback.
  if (LEGACY_CATEGORY_MAPPING.hasOwnProperty(settings.category)) {
    settings.category = LEGACY_CATEGORY_MAPPING[settings.category];
  }
  if ('category' in settings && !select.getCategories().some(({
    slug
  }) => slug === settings.category)) {
    warn('The block "' + name + '" is registered with an invalid category "' + settings.category + '".');
    delete settings.category;
  }
  if (!('title' in settings) || settings.title === '') {
    error('The block "' + name + '" must have a title.');
    return;
  }
  if (typeof settings.title !== 'string') {
    error('Block titles must be strings.');
    return;
  }
  settings.icon = (0, _utils.normalizeIconObject)(settings.icon);
  if (!(0, _utils.isValidIcon)(settings.icon.src)) {
    error('The icon passed is invalid. ' + 'The icon should be a string, an element, a function, or an object following the specifications documented in https://developer.wordpress.org/block-editor/developers/block-api/block-registration/#icon-optional');
    return;
  }
  return settings;
};
exports.processBlockType = processBlockType;
//# sourceMappingURL=process-block-type.js.map