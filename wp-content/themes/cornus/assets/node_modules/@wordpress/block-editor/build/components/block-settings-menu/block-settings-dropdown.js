"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BlockSettingsDropdown = BlockSettingsDropdown;
exports.default = void 0;
var _react = require("react");
var _blocks = require("@wordpress/blocks");
var _components = require("@wordpress/components");
var _data = require("@wordpress/data");
var _icons = require("@wordpress/icons");
var _element = require("@wordpress/element");
var _i18n = require("@wordpress/i18n");
var _keyboardShortcuts = require("@wordpress/keyboard-shortcuts");
var _compose = require("@wordpress/compose");
var _blockActions = _interopRequireDefault(require("../block-actions"));
var _blockHtmlConvertButton = _interopRequireDefault(require("./block-html-convert-button"));
var _blockSettingsMenuFirstItem = _interopRequireDefault(require("./block-settings-menu-first-item"));
var _blockSettingsMenuControls = _interopRequireDefault(require("../block-settings-menu-controls"));
var _blockParentSelectorMenuItem = _interopRequireDefault(require("./block-parent-selector-menu-item"));
var _store = require("../../store");
var _lockUnlock = require("../../lock-unlock");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const POPOVER_PROPS = {
  className: 'block-editor-block-settings-menu__popover',
  placement: 'bottom-start'
};
function CopyMenuItem({
  clientIds,
  onCopy,
  label
}) {
  const {
    getBlocksByClientId
  } = (0, _data.useSelect)(_store.store);
  const ref = (0, _compose.useCopyToClipboard)(() => (0, _blocks.serialize)(getBlocksByClientId(clientIds)), onCopy);
  const copyMenuItemLabel = label ? label : (0, _i18n.__)('Copy');
  return (0, _react.createElement)(_components.MenuItem, {
    ref: ref
  }, copyMenuItemLabel);
}
function BlockSettingsDropdown({
  block,
  clientIds,
  __experimentalSelectBlock,
  children,
  __unstableDisplayLocation,
  ...props
}) {
  // Get the client id of the current block for this menu, if one is set.
  const currentClientId = block?.clientId;
  const blockClientIds = Array.isArray(clientIds) ? clientIds : [clientIds];
  const count = blockClientIds.length;
  const firstBlockClientId = blockClientIds[0];
  const {
    firstParentClientId,
    onlyBlock,
    parentBlockType,
    previousBlockClientId,
    selectedBlockClientIds,
    openedBlockSettingsMenu
  } = (0, _data.useSelect)(select => {
    const {
      getBlockCount,
      getBlockName,
      getBlockRootClientId,
      getPreviousBlockClientId,
      getSelectedBlockClientIds,
      getBlockAttributes,
      getOpenedBlockSettingsMenu
    } = (0, _lockUnlock.unlock)(select(_store.store));
    const {
      getActiveBlockVariation
    } = select(_blocks.store);
    const _firstParentClientId = getBlockRootClientId(firstBlockClientId);
    const parentBlockName = _firstParentClientId && getBlockName(_firstParentClientId);
    return {
      firstParentClientId: _firstParentClientId,
      onlyBlock: 1 === getBlockCount(_firstParentClientId),
      parentBlockType: _firstParentClientId && (getActiveBlockVariation(parentBlockName, getBlockAttributes(_firstParentClientId)) || (0, _blocks.getBlockType)(parentBlockName)),
      previousBlockClientId: getPreviousBlockClientId(firstBlockClientId),
      selectedBlockClientIds: getSelectedBlockClientIds(),
      openedBlockSettingsMenu: getOpenedBlockSettingsMenu()
    };
  }, [firstBlockClientId]);
  const {
    getBlockOrder,
    getSelectedBlockClientIds
  } = (0, _data.useSelect)(_store.store);
  const {
    setOpenedBlockSettingsMenu
  } = (0, _lockUnlock.unlock)((0, _data.useDispatch)(_store.store));
  const shortcuts = (0, _data.useSelect)(select => {
    const {
      getShortcutRepresentation
    } = select(_keyboardShortcuts.store);
    return {
      duplicate: getShortcutRepresentation('core/block-editor/duplicate'),
      remove: getShortcutRepresentation('core/block-editor/remove'),
      insertAfter: getShortcutRepresentation('core/block-editor/insert-after'),
      insertBefore: getShortcutRepresentation('core/block-editor/insert-before')
    };
  }, []);
  const isMatch = (0, _keyboardShortcuts.__unstableUseShortcutEventMatch)();
  const hasSelectedBlocks = selectedBlockClientIds.length > 0;
  const updateSelectionAfterDuplicate = (0, _element.useCallback)(async clientIdsPromise => {
    if (__experimentalSelectBlock) {
      const ids = await clientIdsPromise;
      if (ids && ids[0]) {
        __experimentalSelectBlock(ids[0], false);
      }
    }
  }, [__experimentalSelectBlock]);
  const updateSelectionAfterRemove = (0, _element.useCallback)(() => {
    if (__experimentalSelectBlock) {
      let blockToFocus = previousBlockClientId || firstParentClientId;

      // Focus the first block if there's no previous block nor parent block.
      if (!blockToFocus) {
        blockToFocus = getBlockOrder()[0];
      }

      // Only update the selection if the original selection is removed.
      const shouldUpdateSelection = hasSelectedBlocks && getSelectedBlockClientIds().length === 0;
      __experimentalSelectBlock(blockToFocus, shouldUpdateSelection);
    }
  }, [__experimentalSelectBlock, previousBlockClientId, firstParentClientId, getBlockOrder, hasSelectedBlocks, getSelectedBlockClientIds]);

  // This can occur when the selected block (the parent)
  // displays child blocks within a List View.
  const parentBlockIsSelected = selectedBlockClientIds?.includes(firstParentClientId);

  // When a currentClientId is in use, treat the menu as a controlled component.
  // This ensures that only one block settings menu is open at a time.
  // This is a temporary solution to work around an issue with `onFocusOutside`
  // where it does not allow a dropdown to be closed if focus was never within
  // the dropdown to begin with. Examples include a user either CMD+Clicking or
  // right clicking into an inactive window.
  // See: https://github.com/WordPress/gutenberg/pull/54083
  const open = !currentClientId ? undefined : openedBlockSettingsMenu === currentClientId || false;
  const onToggle = (0, _element.useCallback)(localOpen => {
    if (localOpen && openedBlockSettingsMenu !== currentClientId) {
      setOpenedBlockSettingsMenu(currentClientId);
    } else if (!localOpen && openedBlockSettingsMenu && openedBlockSettingsMenu === currentClientId) {
      setOpenedBlockSettingsMenu(undefined);
    }
  }, [currentClientId, openedBlockSettingsMenu, setOpenedBlockSettingsMenu]);
  return (0, _react.createElement)(_blockActions.default, {
    clientIds: clientIds,
    __experimentalUpdateSelection: !__experimentalSelectBlock
  }, ({
    canCopyStyles,
    canDuplicate,
    canInsertBlock,
    canMove,
    canRemove,
    onDuplicate,
    onInsertAfter,
    onInsertBefore,
    onRemove,
    onCopy,
    onPasteStyles,
    onMoveTo
  }) => (0, _react.createElement)(_components.DropdownMenu, {
    icon: _icons.moreVertical,
    label: (0, _i18n.__)('Options'),
    className: "block-editor-block-settings-menu",
    popoverProps: POPOVER_PROPS,
    open: open,
    onToggle: onToggle,
    noIcons: true,
    menuProps: {
      /**
       * @param {KeyboardEvent} event
       */
      onKeyDown(event) {
        if (event.defaultPrevented) return;
        if (isMatch('core/block-editor/remove', event) && canRemove) {
          event.preventDefault();
          updateSelectionAfterRemove(onRemove());
        } else if (isMatch('core/block-editor/duplicate', event) && canDuplicate) {
          event.preventDefault();
          updateSelectionAfterDuplicate(onDuplicate());
        } else if (isMatch('core/block-editor/insert-after', event) && canInsertBlock) {
          event.preventDefault();
          setOpenedBlockSettingsMenu(undefined);
          onInsertAfter();
        } else if (isMatch('core/block-editor/insert-before', event) && canInsertBlock) {
          event.preventDefault();
          setOpenedBlockSettingsMenu(undefined);
          onInsertBefore();
        }
      }
    },
    ...props
  }, ({
    onClose
  }) => (0, _react.createElement)(_react.Fragment, null, (0, _react.createElement)(_components.MenuGroup, null, (0, _react.createElement)(_blockSettingsMenuFirstItem.default.Slot, {
    fillProps: {
      onClose
    }
  }), !parentBlockIsSelected && !!firstParentClientId && (0, _react.createElement)(_blockParentSelectorMenuItem.default, {
    parentClientId: firstParentClientId,
    parentBlockType: parentBlockType
  }), count === 1 && (0, _react.createElement)(_blockHtmlConvertButton.default, {
    clientId: firstBlockClientId
  }), (0, _react.createElement)(CopyMenuItem, {
    clientIds: clientIds,
    onCopy: onCopy
  }), canDuplicate && (0, _react.createElement)(_components.MenuItem, {
    onClick: (0, _compose.pipe)(onClose, onDuplicate, updateSelectionAfterDuplicate),
    shortcut: shortcuts.duplicate
  }, (0, _i18n.__)('Duplicate')), canInsertBlock && (0, _react.createElement)(_react.Fragment, null, (0, _react.createElement)(_components.MenuItem, {
    onClick: (0, _compose.pipe)(onClose, onInsertBefore),
    shortcut: shortcuts.insertBefore
  }, (0, _i18n.__)('Add before')), (0, _react.createElement)(_components.MenuItem, {
    onClick: (0, _compose.pipe)(onClose, onInsertAfter),
    shortcut: shortcuts.insertAfter
  }, (0, _i18n.__)('Add after')))), canCopyStyles && (0, _react.createElement)(_components.MenuGroup, null, (0, _react.createElement)(CopyMenuItem, {
    clientIds: clientIds,
    onCopy: onCopy,
    label: (0, _i18n.__)('Copy styles')
  }), (0, _react.createElement)(_components.MenuItem, {
    onClick: onPasteStyles
  }, (0, _i18n.__)('Paste styles'))), (0, _react.createElement)(_blockSettingsMenuControls.default.Slot, {
    fillProps: {
      onClose,
      canMove,
      onMoveTo,
      onlyBlock,
      count,
      firstBlockClientId
    },
    clientIds: clientIds,
    __unstableDisplayLocation: __unstableDisplayLocation
  }), typeof children === 'function' ? children({
    onClose
  }) : _element.Children.map(child => (0, _element.cloneElement)(child, {
    onClose
  })), canRemove && (0, _react.createElement)(_components.MenuGroup, null, (0, _react.createElement)(_components.MenuItem, {
    onClick: (0, _compose.pipe)(onClose, onRemove, updateSelectionAfterRemove),
    shortcut: shortcuts.remove
  }, (0, _i18n.__)('Delete'))))));
}
var _default = exports.default = BlockSettingsDropdown;
//# sourceMappingURL=block-settings-dropdown.js.map