{"version":3,"names":["useMemo","cloneBlock","getMatchingBlockByName","getRetainedBlockAttributes","transformMatchingBlock","match","selectedBlock","retainedBlockAttributes","name","attributes","getPatternTransformedBlocks","selectedBlocks","patternBlocks","_patternBlocks","map","block","consumedBlocks","Set","isMatch","patternBlock","add","clientId","useTransformedPatterns","patterns","reduce","accumulator","_pattern","transformedBlocks","blocks","push"],"sources":["@wordpress/block-editor/src/components/block-switcher/use-transformed-patterns.js"],"sourcesContent":["/**\n * WordPress dependencies\n */\nimport { useMemo } from '@wordpress/element';\nimport { cloneBlock } from '@wordpress/blocks';\n\n/**\n * Internal dependencies\n */\nimport { getMatchingBlockByName, getRetainedBlockAttributes } from './utils';\n\n/**\n * Mutate the matched block's attributes by getting\n * which block type's attributes to retain and prioritize\n * them in the merging of the attributes.\n *\n * @param {WPBlock} match         The matched block.\n * @param {WPBlock} selectedBlock The selected block.\n * @return {void}\n */\nexport const transformMatchingBlock = ( match, selectedBlock ) => {\n\t// Get the block attributes to retain through the transformation.\n\tconst retainedBlockAttributes = getRetainedBlockAttributes(\n\t\tselectedBlock.name,\n\t\tselectedBlock.attributes\n\t);\n\tmatch.attributes = {\n\t\t...match.attributes,\n\t\t...retainedBlockAttributes,\n\t};\n};\n\n/**\n * By providing the selected blocks and pattern's blocks\n * find the matching blocks, transform them and return them.\n * If not all selected blocks are matched, return nothing.\n *\n * @param {WPBlock[]} selectedBlocks The selected blocks.\n * @param {WPBlock[]} patternBlocks  The pattern's blocks.\n * @return {WPBlock[]|void} The transformed pattern's blocks or undefined if not all selected blocks have been matched.\n */\nexport const getPatternTransformedBlocks = (\n\tselectedBlocks,\n\tpatternBlocks\n) => {\n\t// Clone Pattern's blocks to produce new clientIds and be able to mutate the matches.\n\tconst _patternBlocks = patternBlocks.map( ( block ) =>\n\t\tcloneBlock( block )\n\t);\n\t/**\n\t * Keep track of the consumed pattern blocks.\n\t * This is needed because we loop the selected blocks\n\t * and for example we may have selected two paragraphs and\n\t * the pattern's blocks could have more `paragraphs`.\n\t */\n\tconst consumedBlocks = new Set();\n\tfor ( const selectedBlock of selectedBlocks ) {\n\t\tlet isMatch = false;\n\t\tfor ( const patternBlock of _patternBlocks ) {\n\t\t\tconst match = getMatchingBlockByName(\n\t\t\t\tpatternBlock,\n\t\t\t\tselectedBlock.name,\n\t\t\t\tconsumedBlocks\n\t\t\t);\n\t\t\tif ( ! match ) continue;\n\t\t\tisMatch = true;\n\t\t\tconsumedBlocks.add( match.clientId );\n\t\t\t// We update (mutate) the matching pattern block.\n\t\t\ttransformMatchingBlock( match, selectedBlock );\n\t\t\t// No need to loop through other pattern's blocks.\n\t\t\tbreak;\n\t\t}\n\t\t// Bail eary if a selected block has not been matched.\n\t\tif ( ! isMatch ) return;\n\t}\n\treturn _patternBlocks;\n};\n\n/**\n * @typedef {WPBlockPattern & {transformedBlocks: WPBlock[]}} TransformedBlockPattern\n */\n\n/**\n * Custom hook that accepts patterns from state and the selected\n * blocks and tries to match these with the pattern's blocks.\n * If all selected blocks are matched with a Pattern's block,\n * we transform them by retaining block's attributes with `role:content`.\n * The transformed pattern's blocks are set to a new pattern\n * property `transformedBlocks`.\n *\n * @param {WPBlockPattern[]} patterns       Patterns from state.\n * @param {WPBlock[]}        selectedBlocks The currently selected blocks.\n * @return {TransformedBlockPattern[]} Returns the eligible matched patterns with all the selected blocks.\n */\nconst useTransformedPatterns = ( patterns, selectedBlocks ) => {\n\treturn useMemo(\n\t\t() =>\n\t\t\tpatterns.reduce( ( accumulator, _pattern ) => {\n\t\t\t\tconst transformedBlocks = getPatternTransformedBlocks(\n\t\t\t\t\tselectedBlocks,\n\t\t\t\t\t_pattern.blocks\n\t\t\t\t);\n\t\t\t\tif ( transformedBlocks ) {\n\t\t\t\t\taccumulator.push( {\n\t\t\t\t\t\t..._pattern,\n\t\t\t\t\t\ttransformedBlocks,\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t\treturn accumulator;\n\t\t\t}, [] ),\n\t\t[ patterns, selectedBlocks ]\n\t);\n};\n\nexport default useTransformedPatterns;\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,OAAO,QAAQ,oBAAoB;AAC5C,SAASC,UAAU,QAAQ,mBAAmB;;AAE9C;AACA;AACA;AACA,SAASC,sBAAsB,EAAEC,0BAA0B,QAAQ,SAAS;;AAE5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,sBAAsB,GAAGA,CAAEC,KAAK,EAAEC,aAAa,KAAM;EACjE;EACA,MAAMC,uBAAuB,GAAGJ,0BAA0B,CACzDG,aAAa,CAACE,IAAI,EAClBF,aAAa,CAACG,UACf,CAAC;EACDJ,KAAK,CAACI,UAAU,GAAG;IAClB,GAAGJ,KAAK,CAACI,UAAU;IACnB,GAAGF;EACJ,CAAC;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMG,2BAA2B,GAAGA,CAC1CC,cAAc,EACdC,aAAa,KACT;EACJ;EACA,MAAMC,cAAc,GAAGD,aAAa,CAACE,GAAG,CAAIC,KAAK,IAChDd,UAAU,CAAEc,KAAM,CACnB,CAAC;EACD;AACD;AACA;AACA;AACA;AACA;EACC,MAAMC,cAAc,GAAG,IAAIC,GAAG,CAAC,CAAC;EAChC,KAAM,MAAMX,aAAa,IAAIK,cAAc,EAAG;IAC7C,IAAIO,OAAO,GAAG,KAAK;IACnB,KAAM,MAAMC,YAAY,IAAIN,cAAc,EAAG;MAC5C,MAAMR,KAAK,GAAGH,sBAAsB,CACnCiB,YAAY,EACZb,aAAa,CAACE,IAAI,EAClBQ,cACD,CAAC;MACD,IAAK,CAAEX,KAAK,EAAG;MACfa,OAAO,GAAG,IAAI;MACdF,cAAc,CAACI,GAAG,CAAEf,KAAK,CAACgB,QAAS,CAAC;MACpC;MACAjB,sBAAsB,CAAEC,KAAK,EAAEC,aAAc,CAAC;MAC9C;MACA;IACD;IACA;IACA,IAAK,CAAEY,OAAO,EAAG;EAClB;EACA,OAAOL,cAAc;AACtB,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMS,sBAAsB,GAAGA,CAAEC,QAAQ,EAAEZ,cAAc,KAAM;EAC9D,OAAOX,OAAO,CACb,MACCuB,QAAQ,CAACC,MAAM,CAAE,CAAEC,WAAW,EAAEC,QAAQ,KAAM;IAC7C,MAAMC,iBAAiB,GAAGjB,2BAA2B,CACpDC,cAAc,EACde,QAAQ,CAACE,MACV,CAAC;IACD,IAAKD,iBAAiB,EAAG;MACxBF,WAAW,CAACI,IAAI,CAAE;QACjB,GAAGH,QAAQ;QACXC;MACD,CAAE,CAAC;IACJ;IACA,OAAOF,WAAW;EACnB,CAAC,EAAE,EAAG,CAAC,EACR,CAAEF,QAAQ,EAAEZ,cAAc,CAC3B,CAAC;AACF,CAAC;AAED,eAAeW,sBAAsB"}