"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = require("react");
var _classnames = _interopRequireDefault(require("classnames"));
var _blocks = require("@wordpress/blocks");
var _components = require("@wordpress/components");
var _element = require("@wordpress/element");
var _icons = require("@wordpress/icons");
var _keycodes = require("@wordpress/keycodes");
var _data = require("@wordpress/data");
var _keyboardShortcuts = require("@wordpress/keyboard-shortcuts");
var _i18n = require("@wordpress/i18n");
var _isShallowEqual = _interopRequireDefault(require("@wordpress/is-shallow-equal"));
var _blockIcon = _interopRequireDefault(require("../block-icon"));
var _useBlockDisplayInformation = _interopRequireDefault(require("../use-block-display-information"));
var _useBlockDisplayTitle = _interopRequireDefault(require("../block-title/use-block-display-title"));
var _expander = _interopRequireDefault(require("./expander"));
var _blockLock = require("../block-lock");
var _store = require("../../store");
var _useListViewImages = _interopRequireDefault(require("./use-list-view-images"));
var _context = require("./context");
var _useBindingsAttributes = require("../../hooks/use-bindings-attributes");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

function ListViewBlockSelectButton({
  className,
  block: {
    clientId,
    name: blockName
  },
  onClick,
  onContextMenu,
  onMouseDown,
  onToggleExpanded,
  tabIndex,
  onFocus,
  onDragStart,
  onDragEnd,
  draggable,
  isExpanded,
  ariaLabel,
  ariaDescribedBy,
  updateFocusAndSelection
}, ref) {
  const blockInformation = (0, _useBlockDisplayInformation.default)(clientId);
  const blockTitle = (0, _useBlockDisplayTitle.default)({
    clientId,
    context: 'list-view'
  });
  const {
    isLocked
  } = (0, _blockLock.useBlockLock)(clientId);
  const {
    canInsertBlockType,
    getSelectedBlockClientIds,
    getPreviousBlockClientId,
    getBlockRootClientId,
    getBlockOrder,
    getBlocksByClientId,
    getBlockAttributes,
    canRemoveBlocks
  } = (0, _data.useSelect)(_store.store);
  const {
    duplicateBlocks,
    multiSelect,
    removeBlocks
  } = (0, _data.useDispatch)(_store.store);
  const isMatch = (0, _keyboardShortcuts.__unstableUseShortcutEventMatch)();
  const isSticky = blockInformation?.positionType === 'sticky';
  const images = (0, _useListViewImages.default)({
    clientId,
    isExpanded
  });
  const {
    rootClientId
  } = (0, _context.useListViewContext)();
  const isConnected = getBlockAttributes(clientId)?.metadata?.bindings;
  const positionLabel = blockInformation?.positionLabel ? (0, _i18n.sprintf)(
  // translators: 1: Position of selected block, e.g. "Sticky" or "Fixed".
  (0, _i18n.__)('Position: %1$s'), blockInformation.positionLabel) : '';

  // The `href` attribute triggers the browser's native HTML drag operations.
  // When the link is dragged, the element's outerHTML is set in DataTransfer object as text/html.
  // We need to clear any HTML drag data to prevent `pasteHandler` from firing
  // inside the `useOnBlockDrop` hook.
  const onDragStartHandler = event => {
    event.dataTransfer.clearData();
    onDragStart?.(event);
  };

  // Determine which blocks to update:
  // If the current (focused) block is part of the block selection, use the whole selection.
  // If the focused block is not part of the block selection, only update the focused block.
  function getBlocksToUpdate() {
    const selectedBlockClientIds = getSelectedBlockClientIds();
    const isUpdatingSelectedBlocks = selectedBlockClientIds.includes(clientId);
    const firstBlockClientId = isUpdatingSelectedBlocks ? selectedBlockClientIds[0] : clientId;
    const firstBlockRootClientId = getBlockRootClientId(firstBlockClientId);
    const blocksToUpdate = isUpdatingSelectedBlocks ? selectedBlockClientIds : [clientId];
    return {
      blocksToUpdate,
      firstBlockClientId,
      firstBlockRootClientId,
      selectedBlockClientIds
    };
  }

  /**
   * @param {KeyboardEvent} event
   */
  async function onKeyDownHandler(event) {
    if (event.keyCode === _keycodes.ENTER || event.keyCode === _keycodes.SPACE) {
      onClick(event);
    } else if (event.keyCode === _keycodes.BACKSPACE || event.keyCode === _keycodes.DELETE || isMatch('core/block-editor/remove', event)) {
      var _getPreviousBlockClie;
      const {
        blocksToUpdate: blocksToDelete,
        firstBlockClientId,
        firstBlockRootClientId,
        selectedBlockClientIds
      } = getBlocksToUpdate();

      // Don't update the selection if the blocks cannot be deleted.
      if (!canRemoveBlocks(blocksToDelete, firstBlockRootClientId)) {
        return;
      }
      let blockToFocus = (_getPreviousBlockClie = getPreviousBlockClientId(firstBlockClientId)) !== null && _getPreviousBlockClie !== void 0 ? _getPreviousBlockClie :
      // If the previous block is not found (when the first block is deleted),
      // fallback to focus the parent block.
      firstBlockRootClientId;
      removeBlocks(blocksToDelete, false);

      // Update the selection if the original selection has been removed.
      const shouldUpdateSelection = selectedBlockClientIds.length > 0 && getSelectedBlockClientIds().length === 0;

      // If there's no previous block nor parent block, focus the first block.
      if (!blockToFocus) {
        blockToFocus = getBlockOrder()[0];
      }
      updateFocusAndSelection(blockToFocus, shouldUpdateSelection);
    } else if (isMatch('core/block-editor/duplicate', event)) {
      if (event.defaultPrevented) {
        return;
      }
      event.preventDefault();
      const {
        blocksToUpdate,
        firstBlockRootClientId
      } = getBlocksToUpdate();
      const canDuplicate = getBlocksByClientId(blocksToUpdate).every(block => {
        return !!block && (0, _blocks.hasBlockSupport)(block.name, 'multiple', true) && canInsertBlockType(block.name, firstBlockRootClientId);
      });
      if (canDuplicate) {
        const updatedBlocks = await duplicateBlocks(blocksToUpdate, false);
        if (updatedBlocks?.length) {
          // If blocks have been duplicated, focus the first duplicated block.
          updateFocusAndSelection(updatedBlocks[0], false);
        }
      }
    } else if (isMatch('core/block-editor/select-all', event)) {
      if (event.defaultPrevented) {
        return;
      }
      event.preventDefault();
      const {
        firstBlockRootClientId,
        selectedBlockClientIds
      } = getBlocksToUpdate();
      const blockClientIds = getBlockOrder(firstBlockRootClientId);
      if (!blockClientIds.length) {
        return;
      }

      // If we have selected all sibling nested blocks, try selecting up a level.
      // This is a similar implementation to that used by `useSelectAll`.
      // `isShallowEqual` is used for the list view instead of a length check,
      // as the array of siblings of the currently focused block may be a different
      // set of blocks from the current block selection if the user is focused
      // on a different part of the list view from the block selection.
      if ((0, _isShallowEqual.default)(selectedBlockClientIds, blockClientIds)) {
        // Only select up a level if the first block is not the root block.
        // This ensures that the block selection can't break out of the root block
        // used by the list view, if the list view is only showing a partial hierarchy.
        if (firstBlockRootClientId && firstBlockRootClientId !== rootClientId) {
          updateFocusAndSelection(firstBlockRootClientId, true);
          return;
        }
      }

      // Select all while passing `null` to skip focusing to the editor canvas,
      // and retain focus within the list view.
      multiSelect(blockClientIds[0], blockClientIds[blockClientIds.length - 1], null);
    }
  }
  return (0, _react.createElement)(_react.Fragment, null, (0, _react.createElement)(_components.Button, {
    className: (0, _classnames.default)('block-editor-list-view-block-select-button', className),
    onClick: onClick,
    onContextMenu: onContextMenu,
    onKeyDown: onKeyDownHandler,
    onMouseDown: onMouseDown,
    ref: ref,
    tabIndex: tabIndex,
    onFocus: onFocus,
    onDragStart: onDragStartHandler,
    onDragEnd: onDragEnd,
    draggable: draggable,
    href: `#block-${clientId}`,
    "aria-label": ariaLabel,
    "aria-describedby": ariaDescribedBy,
    "aria-expanded": isExpanded
  }, (0, _react.createElement)(_expander.default, {
    onClick: onToggleExpanded
  }), (0, _react.createElement)(_blockIcon.default, {
    icon: blockInformation?.icon,
    showColors: true,
    context: "list-view"
  }), (0, _react.createElement)(_components.__experimentalHStack, {
    alignment: "center",
    className: "block-editor-list-view-block-select-button__label-wrapper",
    justify: "flex-start",
    spacing: 1
  }, (0, _react.createElement)("span", {
    className: "block-editor-list-view-block-select-button__title"
  }, (0, _react.createElement)(_components.__experimentalTruncate, {
    ellipsizeMode: "auto"
  }, blockTitle)), blockInformation?.anchor && (0, _react.createElement)("span", {
    className: "block-editor-list-view-block-select-button__anchor-wrapper"
  }, (0, _react.createElement)(_components.__experimentalTruncate, {
    className: "block-editor-list-view-block-select-button__anchor",
    ellipsizeMode: "auto"
  }, blockInformation.anchor)), isConnected && (0, _useBindingsAttributes.canBindBlock)(blockName) && (0, _react.createElement)("span", {
    className: "block-editor-list-view-block-select-button__bindings"
  }, (0, _react.createElement)(_icons.Icon, {
    icon: _icons.connection
  })), positionLabel && isSticky && (0, _react.createElement)(_components.Tooltip, {
    text: positionLabel
  }, (0, _react.createElement)(_icons.Icon, {
    icon: _icons.pinSmall
  })), images.length ? (0, _react.createElement)("span", {
    className: "block-editor-list-view-block-select-button__images",
    "aria-hidden": true
  }, images.map((image, index) => (0, _react.createElement)("span", {
    className: "block-editor-list-view-block-select-button__image",
    key: image.clientId,
    style: {
      backgroundImage: `url(${image.url})`,
      zIndex: images.length - index // Ensure the first image is on top, and subsequent images are behind.
    }
  }))) : null, isLocked && (0, _react.createElement)("span", {
    className: "block-editor-list-view-block-select-button__lock"
  }, (0, _react.createElement)(_icons.Icon, {
    icon: _icons.lockSmall
  })))));
}
var _default = exports.default = (0, _element.forwardRef)(ListViewBlockSelectButton);
//# sourceMappingURL=block-select-button.js.map