{"version":3,"names":["createBlock","createBlocksFromInnerBlocksTemplate","cloneBlock","__experimentalCloneSanitizedBlock","getPossibleBlockTransformations","switchToBlockType","getBlockTransforms","findTransform","getBlockFromExample","default","parse","serializeRawBlock","getBlockAttributes","parseWithAttributeSchema","pasteHandler","rawHandler","deprecatedGetPhrasingContentSchema","getPhrasingContentSchema","serialize","getBlockInnerHTML","getBlockContent","getBlockDefaultClassName","getBlockMenuDefaultClassName","getSaveElement","getSaveContent","getBlockProps","__unstableGetBlockProps","getInnerBlocksProps","__unstableGetInnerBlocksProps","__unstableSerializeAndClean","isValidBlockContent","validateBlock","getCategories","setCategories","updateCategory","registerBlockType","registerBlockCollection","unregisterBlockType","setFreeformContentHandlerName","getFreeformContentHandlerName","setUnregisteredTypeHandlerName","getUnregisteredTypeHandlerName","setDefaultBlockName","getDefaultBlockName","setGroupingBlockName","getGroupingBlockName","getBlockType","getBlockTypes","getBlockSupport","hasBlockSupport","getBlockVariations","isReusableBlock","isTemplatePart","getChildBlockNames","hasChildBlocks","hasChildBlocksWithInserterSupport","unstable__bootstrapServerSideBlockDefinitions","registerBlockStyle","unregisterBlockStyle","registerBlockVariation","unregisterBlockVariation","isUnmodifiedBlock","isUnmodifiedDefaultBlock","normalizeIconObject","isValidIcon","getBlockLabel","__experimentalGetBlockLabel","getAccessibleBlockLabel","__experimentalGetAccessibleBlockLabel","__experimentalSanitizeBlockAttributes","__experimentalGetBlockAttributesNamesByRole","doBlocksMatchTemplate","synchronizeBlocksWithTemplate","children","node","__EXPERIMENTAL_STYLE_PROPERTY","__EXPERIMENTAL_ELEMENTS","__EXPERIMENTAL_PATHS_WITH_OVERRIDE"],"sources":["@wordpress/blocks/src/api/index.js"],"sourcesContent":["// The blocktype is the most important concept within the block API. It defines\n// all aspects of the block configuration and its interfaces, including `edit`\n// and `save`. The transforms specification allows converting one blocktype to\n// another through formulas defined by either the source or the destination.\n// Switching a blocktype is to be considered a one-way operation implying a\n// transformation in the opposite way has to be handled explicitly.\nexport {\n\tcreateBlock,\n\tcreateBlocksFromInnerBlocksTemplate,\n\tcloneBlock,\n\t__experimentalCloneSanitizedBlock,\n\tgetPossibleBlockTransformations,\n\tswitchToBlockType,\n\tgetBlockTransforms,\n\tfindTransform,\n\tgetBlockFromExample,\n} from './factory';\n\n// The block tree is composed of a collection of block nodes. Blocks contained\n// within other blocks are called inner blocks. An important design\n// consideration is that inner blocks are -- conceptually -- not part of the\n// territory established by the parent block that contains them.\n//\n// This has multiple practical implications: when parsing, we can safely dispose\n// of any block boundary found within a block from the innerHTML property when\n// transfering to state. Not doing so would have a compounding effect on memory\n// and uncertainty over the source of truth. This can be illustrated in how,\n// given a tree of `n` nested blocks, the entry node would have to contain the\n// actual content of each block while each subsequent block node in the state\n// tree would replicate the entire chain `n-1`, meaning the extreme end node\n// would have been replicated `n` times as the tree is traversed and would\n// generate uncertainty as to which one is to hold the current value of the\n// block. For composition, it also means inner blocks can effectively be child\n// components whose mechanisms can be shielded from the `edit` implementation\n// and just passed along.\nexport { default as parse } from './parser';\nexport { serializeRawBlock } from './parser/serialize-raw-block';\nexport {\n\tgetBlockAttributes,\n\tparseWithAttributeSchema,\n} from './parser/get-block-attributes';\n\n// While block transformations account for a specific surface of the API, there\n// are also raw transformations which handle arbitrary sources not made out of\n// blocks but producing block basaed on various heursitics. This includes\n// pasting rich text or HTML data.\nexport {\n\tpasteHandler,\n\trawHandler,\n\tdeprecatedGetPhrasingContentSchema as getPhrasingContentSchema,\n} from './raw-handling';\n\n// The process of serialization aims to deflate the internal memory of the block\n// editor and its state representation back into an HTML valid string. This\n// process restores the document integrity and inserts invisible delimiters\n// around each block with HTML comment boundaries which can contain any extra\n// attributes needed to operate with the block later on.\nexport {\n\tdefault as serialize,\n\tgetBlockInnerHTML as getBlockContent,\n\tgetBlockDefaultClassName,\n\tgetBlockMenuDefaultClassName,\n\tgetSaveElement,\n\tgetSaveContent,\n\tgetBlockProps as __unstableGetBlockProps,\n\tgetInnerBlocksProps as __unstableGetInnerBlocksProps,\n\t__unstableSerializeAndClean,\n} from './serializer';\n\n// Validation is the process of comparing a block source with its output before\n// there is any user input or interaction with a block. When this operation\n// fails -- for whatever reason -- the block is to be considered invalid. As\n// part of validating a block the system will attempt to run the source against\n// any provided deprecation definitions.\n//\n// Worth emphasizing that validation is not a case of whether the markup is\n// merely HTML spec-compliant but about how the editor knows to create such\n// markup and that its inability to create an identical result can be a strong\n// indicator of potential data loss (the invalidation is then a protective\n// measure).\n//\n// The invalidation process can also be deconstructed in phases: 1) validate the\n// block exists; 2) validate the source matches the output; 3) validate the\n// source matches deprecated outputs; 4) work through the significance of\n// differences. These are stacked in a way that favors performance and optimizes\n// for the majority of cases. That is to say, the evaluation logic can become\n// more sophisticated the further down it goes in the process as the cost is\n// accounted for. The first logic checks have to be extremely efficient since\n// they will be run for all valid and invalid blocks alike. However, once a\n// block is detected as invalid -- failing the three first steps -- it is\n// adequate to spend more time determining validity before throwing a conflict.\nexport { isValidBlockContent, validateBlock } from './validation';\nexport { getCategories, setCategories, updateCategory } from './categories';\n\n// Blocks are inherently indifferent about where the data they operate with ends\n// up being saved. For example, all blocks can have a static and dynamic aspect\n// to them depending on the needs. The static nature of a block is the `save()`\n// definition that is meant to be serialized into HTML and which can be left\n// void. Any block can also register a `render_callback` on the server, which\n// makes its output dynamic either in part or in its totality.\n//\n// Child blocks are defined as a relationship that builds on top of the inner\n// blocks mechanism. A child block is a block node of a particular type that can\n// only exist within the inner block boundaries of a specific parent type. This\n// allows block authors to compose specific blocks that are not meant to be used\n// outside of a specified parent block context. Thus, child blocks extend the\n// concept of inner blocks to support a more direct relationship between sets of\n// blocks. The addition of parentâ€“child would be a subset of the inner block\n// functionality under the premise that certain blocks only make sense as\n// children of another block.\nexport {\n\tregisterBlockType,\n\tregisterBlockCollection,\n\tunregisterBlockType,\n\tsetFreeformContentHandlerName,\n\tgetFreeformContentHandlerName,\n\tsetUnregisteredTypeHandlerName,\n\tgetUnregisteredTypeHandlerName,\n\tsetDefaultBlockName,\n\tgetDefaultBlockName,\n\tsetGroupingBlockName,\n\tgetGroupingBlockName,\n\tgetBlockType,\n\tgetBlockTypes,\n\tgetBlockSupport,\n\thasBlockSupport,\n\tgetBlockVariations,\n\tisReusableBlock,\n\tisTemplatePart,\n\tgetChildBlockNames,\n\thasChildBlocks,\n\thasChildBlocksWithInserterSupport,\n\tunstable__bootstrapServerSideBlockDefinitions, // eslint-disable-line camelcase\n\tregisterBlockStyle,\n\tunregisterBlockStyle,\n\tregisterBlockVariation,\n\tunregisterBlockVariation,\n} from './registration';\nexport {\n\tisUnmodifiedBlock,\n\tisUnmodifiedDefaultBlock,\n\tnormalizeIconObject,\n\tisValidIcon,\n\tgetBlockLabel as __experimentalGetBlockLabel,\n\tgetAccessibleBlockLabel as __experimentalGetAccessibleBlockLabel,\n\t__experimentalSanitizeBlockAttributes,\n\t__experimentalGetBlockAttributesNamesByRole,\n} from './utils';\n\n// Templates are, in a general sense, a basic collection of block nodes with any\n// given set of predefined attributes that are supplied as the initial state of\n// an inner blocks group. These nodes can, in turn, contain any number of nested\n// blocks within their definition. Templates allow both to specify a default\n// state for an editor session or a default set of blocks for any inner block\n// implementation within a specific block.\nexport {\n\tdoBlocksMatchTemplate,\n\tsynchronizeBlocksWithTemplate,\n} from './templates';\nexport { default as children } from './children';\nexport { default as node } from './node';\nexport {\n\t__EXPERIMENTAL_STYLE_PROPERTY,\n\t__EXPERIMENTAL_ELEMENTS,\n\t__EXPERIMENTAL_PATHS_WITH_OVERRIDE,\n} from './constants';\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,SACCA,WAAW,EACXC,mCAAmC,EACnCC,UAAU,EACVC,iCAAiC,EACjCC,+BAA+B,EAC/BC,iBAAiB,EACjBC,kBAAkB,EAClBC,aAAa,EACbC,mBAAmB,QACb,WAAW;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,OAAO,IAAIC,KAAK,QAAQ,UAAU;AAC3C,SAASC,iBAAiB,QAAQ,8BAA8B;AAChE,SACCC,kBAAkB,EAClBC,wBAAwB,QAClB,+BAA+B;;AAEtC;AACA;AACA;AACA;AACA,SACCC,YAAY,EACZC,UAAU,EACVC,kCAAkC,IAAIC,wBAAwB,QACxD,gBAAgB;;AAEvB;AACA;AACA;AACA;AACA;AACA,SACCR,OAAO,IAAIS,SAAS,EACpBC,iBAAiB,IAAIC,eAAe,EACpCC,wBAAwB,EACxBC,4BAA4B,EAC5BC,cAAc,EACdC,cAAc,EACdC,aAAa,IAAIC,uBAAuB,EACxCC,mBAAmB,IAAIC,6BAA6B,EACpDC,2BAA2B,QACrB,cAAc;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,mBAAmB,EAAEC,aAAa,QAAQ,cAAc;AACjE,SAASC,aAAa,EAAEC,aAAa,EAAEC,cAAc,QAAQ,cAAc;;AAE3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SACCC,iBAAiB,EACjBC,uBAAuB,EACvBC,mBAAmB,EACnBC,6BAA6B,EAC7BC,6BAA6B,EAC7BC,8BAA8B,EAC9BC,8BAA8B,EAC9BC,mBAAmB,EACnBC,mBAAmB,EACnBC,oBAAoB,EACpBC,oBAAoB,EACpBC,YAAY,EACZC,aAAa,EACbC,eAAe,EACfC,eAAe,EACfC,kBAAkB,EAClBC,eAAe,EACfC,cAAc,EACdC,kBAAkB,EAClBC,cAAc,EACdC,iCAAiC,EACjCC,6CAA6C;AAAE;AAC/CC,kBAAkB,EAClBC,oBAAoB,EACpBC,sBAAsB,EACtBC,wBAAwB,QAClB,gBAAgB;AACvB,SACCC,iBAAiB,EACjBC,wBAAwB,EACxBC,mBAAmB,EACnBC,WAAW,EACXC,aAAa,IAAIC,2BAA2B,EAC5CC,uBAAuB,IAAIC,qCAAqC,EAChEC,qCAAqC,EACrCC,2CAA2C,QACrC,SAAS;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA,SACCC,qBAAqB,EACrBC,6BAA6B,QACvB,aAAa;AACpB,SAAS/D,OAAO,IAAIgE,QAAQ,QAAQ,YAAY;AAChD,SAAShE,OAAO,IAAIiE,IAAI,QAAQ,QAAQ;AACxC,SACCC,6BAA6B,EAC7BC,uBAAuB,EACvBC,kCAAkC,QAC5B,aAAa"}