"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useEnter = useEnter;
var _element = require("@wordpress/element");
var _compose = require("@wordpress/compose");
var _keycodes = require("@wordpress/keycodes");
var _richText = require("@wordpress/rich-text");
var _blocks = require("@wordpress/blocks");
var _data = require("@wordpress/data");
var _store = require("../../store");
var _splitValue = require("./split-value");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

function useEnter(props) {
  const registry = (0, _data.useRegistry)();
  const {
    __unstableMarkAutomaticChange
  } = (0, _data.useDispatch)(_store.store);
  const propsRef = (0, _element.useRef)(props);
  propsRef.current = props;
  return (0, _compose.useRefEffect)(element => {
    function onKeyDown(event) {
      if (event.target.contentEditable !== 'true') {
        return;
      }
      if (event.defaultPrevented) {
        return;
      }
      if (event.keyCode !== _keycodes.ENTER) {
        return;
      }
      const {
        removeEditorOnlyFormats,
        value,
        onReplace,
        onSplit,
        onChange,
        disableLineBreaks,
        onSplitAtEnd,
        onSplitAtDoubleLineEnd
      } = propsRef.current;
      event.preventDefault();
      const _value = {
        ...value
      };
      _value.formats = removeEditorOnlyFormats(value);
      const canSplit = onReplace && onSplit;
      if (onReplace) {
        const transforms = (0, _blocks.getBlockTransforms)('from').filter(({
          type
        }) => type === 'enter');
        const transformation = (0, _blocks.findTransform)(transforms, item => {
          return item.regExp.test(_value.text);
        });
        if (transformation) {
          onReplace([transformation.transform({
            content: _value.text
          })]);
          __unstableMarkAutomaticChange();
          return;
        }
      }
      const {
        text,
        start,
        end
      } = _value;
      if (event.shiftKey) {
        if (!disableLineBreaks) {
          onChange((0, _richText.insert)(_value, '\n'));
        }
      } else if (canSplit) {
        (0, _splitValue.splitValue)({
          value: _value,
          onReplace,
          onSplit
        });
      } else if (onSplitAtEnd && start === end && end === text.length) {
        onSplitAtEnd();
      } else if (
      // For some blocks it's desirable to split at the end of the
      // block when there are two line breaks at the end of the
      // block, so triple Enter exits the block.
      onSplitAtDoubleLineEnd && start === end && end === text.length && text.slice(-2) === '\n\n') {
        registry.batch(() => {
          _value.start = _value.end - 2;
          onChange((0, _richText.remove)(_value));
          onSplitAtDoubleLineEnd();
        });
      } else if (!disableLineBreaks) {
        onChange((0, _richText.insert)(_value, '\n'));
      }
    }
    element.addEventListener('keydown', onKeyDown);
    return () => {
      element.removeEventListener('keydown', onKeyDown);
    };
  }, []);
}
//# sourceMappingURL=use-enter.js.map