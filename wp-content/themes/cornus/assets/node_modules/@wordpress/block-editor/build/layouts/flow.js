"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _i18n = require("@wordpress/i18n");
var _utils = require("./utils");
var _gap = require("../hooks/gap");
var _utils2 = require("../hooks/utils");
var _definitions = require("./definitions");
/**
 * WordPress dependencies
 */
/**
 * Internal dependencies
 */
var _default = exports.default = {
  name: 'default',
  label: (0, _i18n.__)('Flow'),
  inspectorControls: function DefaultLayoutInspectorControls() {
    return null;
  },
  toolBarControls: function DefaultLayoutToolbarControls() {
    return null;
  },
  getLayoutStyle: function getLayoutStyle({
    selector,
    style,
    blockName,
    hasBlockGapSupport,
    layoutDefinitions = _definitions.LAYOUT_DEFINITIONS
  }) {
    const blockGapStyleValue = (0, _gap.getGapCSSValue)(style?.spacing?.blockGap);

    // If a block's block.json skips serialization for spacing or
    // spacing.blockGap, don't apply the user-defined value to the styles.
    let blockGapValue = '';
    if (!(0, _utils2.shouldSkipSerialization)(blockName, 'spacing', 'blockGap')) {
      // If an object is provided only use the 'top' value for this kind of gap.
      if (blockGapStyleValue?.top) {
        blockGapValue = (0, _gap.getGapCSSValue)(blockGapStyleValue?.top);
      } else if (typeof blockGapStyleValue === 'string') {
        blockGapValue = (0, _gap.getGapCSSValue)(blockGapStyleValue);
      }
    }
    let output = '';

    // Output blockGap styles based on rules contained in layout definitions in theme.json.
    if (hasBlockGapSupport && blockGapValue) {
      output += (0, _utils.getBlockGapCSS)(selector, layoutDefinitions, 'default', blockGapValue);
    }
    return output;
  },
  getOrientation() {
    return 'vertical';
  },
  getAlignments(layout, isBlockBasedTheme) {
    const alignmentInfo = (0, _utils.getAlignmentsInfo)(layout);
    if (layout.alignments !== undefined) {
      if (!layout.alignments.includes('none')) {
        layout.alignments.unshift('none');
      }
      return layout.alignments.map(alignment => ({
        name: alignment,
        info: alignmentInfo[alignment]
      }));
    }
    const alignments = [{
      name: 'left'
    }, {
      name: 'center'
    }, {
      name: 'right'
    }];

    // This is for backwards compatibility with hybrid themes.
    if (!isBlockBasedTheme) {
      const {
        contentSize,
        wideSize
      } = layout;
      if (contentSize) {
        alignments.unshift({
          name: 'full'
        });
      }
      if (wideSize) {
        alignments.unshift({
          name: 'wide',
          info: alignmentInfo.wide
        });
      }
    }
    alignments.unshift({
      name: 'none',
      info: alignmentInfo.none
    });
    return alignments;
  }
};
//# sourceMappingURL=flow.js.map