"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPasteBlocks = getPasteBlocks;
exports.requiresWrapperOnCopy = void 0;
exports.setClipboardBlocks = setClipboardBlocks;
var _dom = require("@wordpress/dom");
var _blocks2 = require("@wordpress/blocks");
var _pasting = require("../../utils/pasting");
var _store = require("../../store");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const requiresWrapperOnCopy = exports.requiresWrapperOnCopy = Symbol('requiresWrapperOnCopy');

/**
 * Sets the clipboard data for the provided blocks, with both HTML and plain
 * text representations.
 *
 * @param {ClipboardEvent} event    Clipboard event.
 * @param {WPBlock[]}      blocks   Blocks to set as clipboard data.
 * @param {Object}         registry The registry to select from.
 */
function setClipboardBlocks(event, blocks, registry) {
  let _blocks = blocks;
  const [firstBlock] = blocks;
  if (firstBlock) {
    const firstBlockType = registry.select(_blocks2.store).getBlockType(firstBlock.name);
    if (firstBlockType[requiresWrapperOnCopy]) {
      const {
        getBlockRootClientId,
        getBlockName,
        getBlockAttributes
      } = registry.select(_store.store);
      const wrapperBlockClientId = getBlockRootClientId(firstBlock.clientId);
      const wrapperBlockName = getBlockName(wrapperBlockClientId);
      if (wrapperBlockName) {
        _blocks = (0, _blocks2.createBlock)(wrapperBlockName, getBlockAttributes(wrapperBlockClientId), _blocks);
      }
    }
  }
  const serialized = (0, _blocks2.serialize)(_blocks);
  event.clipboardData.setData('text/plain', toPlainText(serialized));
  event.clipboardData.setData('text/html', serialized);
}

/**
 * Returns the blocks to be pasted from the clipboard event.
 *
 * @param {ClipboardEvent} event                    The clipboard event.
 * @param {boolean}        canUserUseUnfilteredHTML Whether the user can or can't post unfiltered HTML.
 * @return {Array|string} A list of blocks or a string, depending on `handlerMode`.
 */
function getPasteBlocks(event, canUserUseUnfilteredHTML) {
  const {
    plainText,
    html,
    files
  } = (0, _pasting.getPasteEventData)(event);
  let blocks = [];
  if (files.length) {
    const fromTransforms = (0, _blocks2.getBlockTransforms)('from');
    blocks = files.reduce((accumulator, file) => {
      const transformation = (0, _blocks2.findTransform)(fromTransforms, transform => transform.type === 'files' && transform.isMatch([file]));
      if (transformation) {
        accumulator.push(transformation.transform([file]));
      }
      return accumulator;
    }, []).flat();
  } else {
    blocks = (0, _blocks2.pasteHandler)({
      HTML: html,
      plainText,
      mode: 'BLOCKS',
      canUserUseUnfilteredHTML
    });
  }
  return blocks;
}

/**
 * Given a string of HTML representing serialized blocks, returns the plain
 * text extracted after stripping the HTML of any tags and fixing line breaks.
 *
 * @param {string} html Serialized blocks.
 * @return {string} The plain-text content with any html removed.
 */
function toPlainText(html) {
  // Manually handle BR tags as line breaks prior to `stripHTML` call
  html = html.replace(/<br>/g, '\n');
  const plainText = (0, _dom.__unstableStripHTML)(html).trim();

  // Merge any consecutive line breaks
  return plainText.replace(/\n\n+/g, '\n\n');
}
//# sourceMappingURL=utils.js.map