"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useShowHoveredOrFocusedGestures = useShowHoveredOrFocusedGestures;
var _data = require("@wordpress/data");
var _element = require("@wordpress/element");
var _store = require("../../store");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const {
  clearTimeout,
  setTimeout
} = window;
const DEBOUNCE_TIMEOUT = 200;

/**
 * Hook that creates debounced callbacks when the node is hovered or focused.
 *
 * @param {Object}  props                       Component props.
 * @param {Object}  props.ref                   Element reference.
 * @param {boolean} props.isFocused             Whether the component has current focus.
 * @param {number}  props.highlightParent       Whether to highlight the parent block. It defaults in highlighting the selected block.
 * @param {number}  [props.debounceTimeout=250] Debounce timeout in milliseconds.
 */
function useDebouncedShowGestures({
  ref,
  isFocused,
  highlightParent,
  debounceTimeout = DEBOUNCE_TIMEOUT
}) {
  const {
    getSelectedBlockClientId,
    getBlockRootClientId
  } = (0, _data.useSelect)(_store.store);
  const {
    toggleBlockHighlight
  } = (0, _data.useDispatch)(_store.store);
  const timeoutRef = (0, _element.useRef)();
  const isDistractionFree = (0, _data.useSelect)(select => select(_store.store).getSettings().isDistractionFree, []);
  const handleOnChange = nextIsFocused => {
    if (nextIsFocused && isDistractionFree) {
      return;
    }
    const selectedBlockClientId = getSelectedBlockClientId();
    const clientId = highlightParent ? getBlockRootClientId(selectedBlockClientId) : selectedBlockClientId;
    toggleBlockHighlight(clientId, nextIsFocused);
  };
  const getIsHovered = () => {
    return ref?.current && ref.current.matches(':hover');
  };
  const shouldHideGestures = () => {
    const isHovered = getIsHovered();
    return !isFocused && !isHovered;
  };
  const clearTimeoutRef = () => {
    const timeout = timeoutRef.current;
    if (timeout && clearTimeout) {
      clearTimeout(timeout);
    }
  };
  const debouncedShowGestures = event => {
    if (event) {
      event.stopPropagation();
    }
    clearTimeoutRef();
    handleOnChange(true);
  };
  const debouncedHideGestures = event => {
    if (event) {
      event.stopPropagation();
    }
    clearTimeoutRef();
    timeoutRef.current = setTimeout(() => {
      if (shouldHideGestures()) {
        handleOnChange(false);
      }
    }, debounceTimeout);
  };
  (0, _element.useEffect)(() => () => {
    /**
     * We need to call the change handler with `isFocused`
     * set to false on unmount because we also clear the
     * timeout that would handle that.
     */
    handleOnChange(false);
    clearTimeoutRef();
  }, []);
  return {
    debouncedShowGestures,
    debouncedHideGestures
  };
}

/**
 * Hook that provides gesture events for DOM elements
 * that interact with the isFocused state.
 *
 * @param {Object} props                         Component props.
 * @param {Object} props.ref                     Element reference.
 * @param {number} [props.highlightParent=false] Whether to highlight the parent block. It defaults to highlighting the selected block.
 * @param {number} [props.debounceTimeout=250]   Debounce timeout in milliseconds.
 */
function useShowHoveredOrFocusedGestures({
  ref,
  highlightParent = false,
  debounceTimeout = DEBOUNCE_TIMEOUT
}) {
  const [isFocused, setIsFocused] = (0, _element.useState)(false);
  const {
    debouncedShowGestures,
    debouncedHideGestures
  } = useDebouncedShowGestures({
    ref,
    debounceTimeout,
    isFocused,
    highlightParent
  });
  const registerRef = (0, _element.useRef)(false);
  const isFocusedWithin = () => {
    return ref?.current && ref.current.contains(ref.current.ownerDocument.activeElement);
  };
  (0, _element.useEffect)(() => {
    const node = ref.current;
    const handleOnFocus = () => {
      if (isFocusedWithin()) {
        setIsFocused(true);
        debouncedShowGestures();
      }
    };
    const handleOnBlur = () => {
      if (!isFocusedWithin()) {
        setIsFocused(false);
        debouncedHideGestures();
      }
    };

    /**
     * Events are added via DOM events (vs. React synthetic events),
     * as the child React components swallow mouse events.
     */
    if (node && !registerRef.current) {
      node.addEventListener('focus', handleOnFocus, true);
      node.addEventListener('blur', handleOnBlur, true);
      registerRef.current = true;
    }
    return () => {
      if (node) {
        node.removeEventListener('focus', handleOnFocus);
        node.removeEventListener('blur', handleOnBlur);
      }
    };
  }, [ref, registerRef, setIsFocused, debouncedShowGestures, debouncedHideGestures]);
  return {
    onMouseMove: debouncedShowGestures,
    onMouseLeave: debouncedHideGestures
  };
}
//# sourceMappingURL=utils.js.map