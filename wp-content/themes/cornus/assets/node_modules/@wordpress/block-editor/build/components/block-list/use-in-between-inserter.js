"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useInBetweenInserter = useInBetweenInserter;
var _compose = require("@wordpress/compose");
var _data = require("@wordpress/data");
var _element = require("@wordpress/element");
var _i18n = require("@wordpress/i18n");
var _store = require("../../store");
var _insertionPoint = require("../block-tools/insertion-point");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

function useInBetweenInserter() {
  const openRef = (0, _element.useContext)(_insertionPoint.InsertionPointOpenRef);
  const isInBetweenInserterDisabled = (0, _data.useSelect)(select => select(_store.store).getSettings().isDistractionFree || select(_store.store).__unstableGetEditorMode() === 'zoom-out', []);
  const {
    getBlockListSettings,
    getBlockIndex,
    isMultiSelecting,
    getSelectedBlockClientIds,
    getTemplateLock,
    __unstableIsWithinBlockOverlay,
    getBlockEditingMode,
    getBlockName
  } = (0, _data.useSelect)(_store.store);
  const {
    showInsertionPoint,
    hideInsertionPoint
  } = (0, _data.useDispatch)(_store.store);
  return (0, _compose.useRefEffect)(node => {
    if (isInBetweenInserterDisabled) {
      return;
    }
    function onMouseMove(event) {
      if (openRef.current) {
        return;
      }

      // Ignore text nodes sometimes detected in FireFox.
      if (event.target.nodeType === event.target.TEXT_NODE) {
        return;
      }
      if (isMultiSelecting()) {
        return;
      }
      if (!event.target.classList.contains('block-editor-block-list__layout')) {
        hideInsertionPoint();
        return;
      }
      let rootClientId;
      if (!event.target.classList.contains('is-root-container')) {
        const blockElement = !!event.target.getAttribute('data-block') ? event.target : event.target.closest('[data-block]');
        rootClientId = blockElement.getAttribute('data-block');
      }
      if (getTemplateLock(rootClientId) || getBlockEditingMode(rootClientId) === 'disabled' || getBlockName(rootClientId) === 'core/block') {
        return;
      }
      const orientation = getBlockListSettings(rootClientId)?.orientation || 'vertical';
      const offsetTop = event.clientY;
      const offsetLeft = event.clientX;
      const children = Array.from(event.target.children);
      let element = children.find(blockEl => {
        const blockElRect = blockEl.getBoundingClientRect();
        return blockEl.classList.contains('wp-block') && orientation === 'vertical' && blockElRect.top > offsetTop || blockEl.classList.contains('wp-block') && orientation === 'horizontal' && ((0, _i18n.isRTL)() ? blockElRect.right < offsetLeft : blockElRect.left > offsetLeft);
      });
      if (!element) {
        hideInsertionPoint();
        return;
      }

      // The block may be in an alignment wrapper, so check the first direct
      // child if the element has no ID.
      if (!element.id) {
        element = element.firstElementChild;
        if (!element) {
          hideInsertionPoint();
          return;
        }
      }

      // Don't show the insertion point if a parent block has an "overlay"
      // See https://github.com/WordPress/gutenberg/pull/34012#pullrequestreview-727762337
      const clientId = element.id.slice('block-'.length);
      if (!clientId || __unstableIsWithinBlockOverlay(clientId)) {
        return;
      }

      // Don't show the inserter when hovering above (conflicts with
      // block toolbar) or inside selected block(s).
      if (getSelectedBlockClientIds().includes(clientId)) {
        return;
      }
      const elementRect = element.getBoundingClientRect();
      if (orientation === 'horizontal' && (event.clientY > elementRect.bottom || event.clientY < elementRect.top) || orientation === 'vertical' && (event.clientX > elementRect.right || event.clientX < elementRect.left)) {
        hideInsertionPoint();
        return;
      }
      const index = getBlockIndex(clientId);

      // Don't show the in-between inserter before the first block in
      // the list (preserves the original behaviour).
      if (index === 0) {
        hideInsertionPoint();
        return;
      }
      showInsertionPoint(rootClientId, index, {
        __unstableWithInserter: true
      });
    }
    node.addEventListener('mousemove', onMouseMove);
    return () => {
      node.removeEventListener('mousemove', onMouseMove);
    };
  }, [openRef, getBlockListSettings, getBlockIndex, isMultiSelecting, showInsertionPoint, hideInsertionPoint, getSelectedBlockClientIds, isInBetweenInserterDisabled]);
}
//# sourceMappingURL=use-in-between-inserter.js.map