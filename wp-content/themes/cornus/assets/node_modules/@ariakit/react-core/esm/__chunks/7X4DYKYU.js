"use client";
import {
  useHovercardProviderContext
} from "./TI7CMBHW.js";
import {
  useFocusable
} from "./KK7H3W2B.js";
import {
  createComponent,
  createElement,
  createHook
} from "./3ORBWXWF.js";
import {
  useBooleanEvent,
  useEvent,
  useIsMouseMoving,
  useMergeRefs
} from "./6O5OEQGF.js";
import {
  __objRest,
  __spreadProps,
  __spreadValues
} from "./4R3V3JGP.js";

// src/hovercard/hovercard-anchor.ts
import { useCallback, useEffect, useRef } from "react";
import { addGlobalEventListener } from "@ariakit/core/utils/events";
import { disabledFromProps, invariant } from "@ariakit/core/utils/misc";
var useHovercardAnchor = createHook(
  (_a) => {
    var _b = _a, { store, showOnHover = true } = _b, props = __objRest(_b, ["store", "showOnHover"]);
    const context = useHovercardProviderContext();
    store = store || context;
    invariant(
      store,
      process.env.NODE_ENV !== "production" && "HovercardAnchor must receive a `store` prop or be wrapped in a HovercardProvider component."
    );
    const disabled = disabledFromProps(props);
    const showTimeoutRef = useRef(0);
    useEffect(() => () => window.clearTimeout(showTimeoutRef.current), []);
    useEffect(() => {
      const onMouseLeave = (event) => {
        if (!store)
          return;
        const { anchorElement } = store.getState();
        if (!anchorElement)
          return;
        if (event.target !== anchorElement)
          return;
        window.clearTimeout(showTimeoutRef.current);
        showTimeoutRef.current = 0;
      };
      return addGlobalEventListener("mouseleave", onMouseLeave, true);
    }, [store]);
    const onMouseMoveProp = props.onMouseMove;
    const showOnHoverProp = useBooleanEvent(showOnHover);
    const isMouseMoving = useIsMouseMoving();
    const onMouseMove = useEvent(
      (event) => {
        onMouseMoveProp == null ? void 0 : onMouseMoveProp(event);
        if (disabled)
          return;
        if (!store)
          return;
        if (event.defaultPrevented)
          return;
        if (showTimeoutRef.current)
          return;
        if (!isMouseMoving())
          return;
        if (!showOnHoverProp(event))
          return;
        const element = event.currentTarget;
        store.setAnchorElement(element);
        store.setDisclosureElement(element);
        const { showTimeout, timeout } = store.getState();
        const showHovercard = () => {
          showTimeoutRef.current = 0;
          if (!isMouseMoving())
            return;
          store == null ? void 0 : store.setAnchorElement(element);
          store == null ? void 0 : store.show();
          queueMicrotask(() => {
            store == null ? void 0 : store.setDisclosureElement(element);
          });
        };
        const timeoutMs = showTimeout != null ? showTimeout : timeout;
        if (timeoutMs === 0) {
          showHovercard();
        } else {
          showTimeoutRef.current = window.setTimeout(showHovercard, timeoutMs);
        }
      }
    );
    const ref = useCallback(
      (element) => {
        if (!store)
          return;
        const { anchorElement } = store.getState();
        if (anchorElement == null ? void 0 : anchorElement.isConnected)
          return;
        store.setAnchorElement(element);
      },
      [store]
    );
    props = __spreadProps(__spreadValues({}, props), {
      ref: useMergeRefs(ref, props.ref),
      onMouseMove
    });
    props = useFocusable(props);
    return props;
  }
);
var HovercardAnchor = createComponent(
  (props) => {
    const htmlProps = useHovercardAnchor(props);
    return createElement("a", htmlProps);
  }
);
if (process.env.NODE_ENV !== "production") {
  HovercardAnchor.displayName = "HovercardAnchor";
}

export {
  useHovercardAnchor,
  HovercardAnchor
};
