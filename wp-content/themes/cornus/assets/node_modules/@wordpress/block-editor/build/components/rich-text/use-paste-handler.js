"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usePasteHandler = usePasteHandler;
var _element = require("@wordpress/element");
var _compose = require("@wordpress/compose");
var _blocks = require("@wordpress/blocks");
var _richText = require("@wordpress/rich-text");
var _url = require("@wordpress/url");
var _utils = require("./utils");
var _splitValue = require("./split-value");
var _pasting = require("../../utils/pasting");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/** @typedef {import('@wordpress/rich-text').RichTextValue} RichTextValue */

function usePasteHandler(props) {
  const propsRef = (0, _element.useRef)(props);
  propsRef.current = props;
  return (0, _compose.useRefEffect)(element => {
    function _onPaste(event) {
      const {
        isSelected,
        disableFormats,
        onChange,
        value,
        formatTypes,
        tagName,
        onReplace,
        onSplit,
        __unstableEmbedURLOnPaste,
        pastePlainText
      } = propsRef.current;
      if (!isSelected) {
        return;
      }
      const {
        plainText,
        html,
        files
      } = (0, _pasting.getPasteEventData)(event);
      event.preventDefault();

      // Allows us to ask for this information when we get a report.
      window.console.log('Received HTML:\n\n', html);
      window.console.log('Received plain text:\n\n', plainText);
      if (disableFormats) {
        onChange((0, _richText.insert)(value, plainText));
        return;
      }
      const isInternal = event.clipboardData.getData('rich-text') === 'true';
      function pasteInline(content) {
        const transformed = formatTypes.reduce((accumulator, {
          __unstablePasteRule
        }) => {
          // Only allow one transform.
          if (__unstablePasteRule && accumulator === value) {
            accumulator = __unstablePasteRule(value, {
              html,
              plainText
            });
          }
          return accumulator;
        }, value);
        if (transformed !== value) {
          onChange(transformed);
        } else {
          const valueToInsert = (0, _richText.create)({
            html: content
          });
          (0, _utils.addActiveFormats)(valueToInsert, value.activeFormats);
          onChange((0, _richText.insert)(value, valueToInsert));
        }
      }

      // If the data comes from a rich text instance, we can directly use it
      // without filtering the data. The filters are only meant for externally
      // pasted content and remove inline styles.
      if (isInternal) {
        pasteInline(html);
        return;
      }
      if (pastePlainText) {
        onChange((0, _richText.insert)(value, (0, _richText.create)({
          text: plainText
        })));
        return;
      }
      if (files?.length) {
        // Allows us to ask for this information when we get a report.
        // eslint-disable-next-line no-console
        window.console.log('Received items:\n\n', files);
        const fromTransforms = (0, _blocks.getBlockTransforms)('from');
        const blocks = files.reduce((accumulator, file) => {
          const transformation = (0, _blocks.findTransform)(fromTransforms, transform => transform.type === 'files' && transform.isMatch([file]));
          if (transformation) {
            accumulator.push(transformation.transform([file]));
          }
          return accumulator;
        }, []).flat();
        if (!blocks.length) {
          return;
        }
        if (onReplace && (0, _richText.isEmpty)(value)) {
          onReplace(blocks);
        } else {
          (0, _splitValue.splitValue)({
            value,
            pastedBlocks: blocks,
            onReplace,
            onSplit
          });
        }
        return;
      }
      let mode = onReplace && onSplit ? 'AUTO' : 'INLINE';
      const trimmedPlainText = plainText.trim();
      if (__unstableEmbedURLOnPaste && (0, _richText.isEmpty)(value) && (0, _url.isURL)(trimmedPlainText) &&
      // For the link pasting feature, allow only http(s) protocols.
      /^https?:/.test(trimmedPlainText)) {
        mode = 'BLOCKS';
      }
      const content = (0, _blocks.pasteHandler)({
        HTML: html,
        plainText,
        mode,
        tagName
      });
      if (typeof content === 'string') {
        pasteInline(content);
      } else if (content.length > 0) {
        if (onReplace && (0, _richText.isEmpty)(value)) {
          onReplace(content, content.length - 1, -1);
        } else {
          (0, _splitValue.splitValue)({
            value,
            pastedBlocks: content,
            onReplace,
            onSplit
          });
        }
      }
    }
    element.addEventListener('paste', _onPaste);
    return () => {
      element.removeEventListener('paste', _onPaste);
    };
  }, []);
}
//# sourceMappingURL=use-paste-handler.js.map