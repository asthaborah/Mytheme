import { createElement } from "react";
/**
 * External dependencies
 */
// eslint-disable-next-line no-restricted-imports
import * as Ariakit from '@ariakit/react';

/**
 * WordPress dependencies
 */
import { useInstanceId } from '@wordpress/compose';
import { Children, useContext, createContext, forwardRef } from '@wordpress/element';
import deprecated from '@wordpress/deprecated';

/**
 * Internal dependencies
 */

import Shortcut from '../shortcut';
import { positionToPlacement } from '../popover/utils';
const TooltipInternalContext = createContext({
  isNestedInTooltip: false
});

/**
 * Time over anchor to wait before showing tooltip
 */
export const TOOLTIP_DELAY = 700;
const CONTEXT_VALUE = {
  isNestedInTooltip: true
};
function UnforwardedTooltip(props, ref) {
  const {
    children,
    delay = TOOLTIP_DELAY,
    hideOnClick = true,
    placement,
    position,
    shortcut,
    text,
    ...restProps
  } = props;
  const {
    isNestedInTooltip
  } = useContext(TooltipInternalContext);
  const baseId = useInstanceId(Tooltip, 'tooltip');
  const describedById = text || shortcut ? baseId : undefined;
  const isOnlyChild = Children.count(children) === 1;
  // console error if more than one child element is added
  if (!isOnlyChild) {
    if ('development' === process.env.NODE_ENV) {
      // eslint-disable-next-line no-console
      console.error('wp-components.Tooltip should be called with only a single child element.');
    }
  }

  // Compute tooltip's placement:
  // - give priority to `placement` prop, if defined
  // - otherwise, compute it from the legacy `position` prop (if defined)
  // - finally, fallback to the default placement: 'bottom'
  let computedPlacement;
  if (placement !== undefined) {
    computedPlacement = placement;
  } else if (position !== undefined) {
    computedPlacement = positionToPlacement(position);
    deprecated('`position` prop in wp.components.tooltip', {
      since: '6.4',
      alternative: '`placement` prop'
    });
  }
  computedPlacement = computedPlacement || 'bottom';

  // Removing the `Ariakit` namespace from the hook name allows ESLint to
  // properly identify the hook, and apply the correct linting rules.
  const useAriakitTooltipStore = Ariakit.useTooltipStore;
  const tooltipStore = useAriakitTooltipStore({
    placement: computedPlacement,
    showTimeout: delay
  });
  if (isNestedInTooltip) {
    return isOnlyChild ? createElement(Ariakit.Role, {
      ...restProps,
      render: children
    }) : children;
  }
  return createElement(TooltipInternalContext.Provider, {
    value: CONTEXT_VALUE
  }, createElement(Ariakit.TooltipAnchor, {
    onClick: hideOnClick ? tooltipStore.hide : undefined,
    store: tooltipStore,
    render: isOnlyChild ? children : undefined,
    ref: ref
  }, isOnlyChild ? undefined : children), isOnlyChild && (text || shortcut) && createElement(Ariakit.Tooltip, {
    ...restProps,
    className: "components-tooltip",
    unmountOnHide: true,
    gutter: 4,
    id: describedById,
    overflowPadding: 0.5,
    store: tooltipStore
  }, text, shortcut && createElement(Shortcut, {
    className: text ? 'components-tooltip__shortcut' : '',
    shortcut: shortcut
  })));
}
export const Tooltip = forwardRef(UnforwardedTooltip);
export default Tooltip;
//# sourceMappingURL=index.js.map