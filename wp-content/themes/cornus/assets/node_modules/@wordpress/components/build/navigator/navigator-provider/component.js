"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.NavigatorProvider = void 0;
var _react = require("react");
var _element = require("@wordpress/element");
var _isShallowEqual = _interopRequireDefault(require("@wordpress/is-shallow-equal"));
var _context = require("../../context");
var _useCx = require("../../utils/hooks/use-cx");
var _router = require("../utils/router");
var _view = require("../../view");
var _context2 = require("../context");
var styles = _interopRequireWildcard(require("../styles"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

const MAX_HISTORY_LENGTH = 50;
function screensReducer(state = [], action) {
  switch (action.type) {
    case 'add':
      return [...state, action.screen];
    case 'remove':
      return state.filter(s => s.id !== action.screen.id);
  }
  return state;
}
function UnconnectedNavigatorProvider(props, forwardedRef) {
  const {
    initialPath,
    children,
    className,
    ...otherProps
  } = (0, _context.useContextSystem)(props, 'NavigatorProvider');
  const [locationHistory, setLocationHistory] = (0, _element.useState)([{
    path: initialPath
  }]);
  const currentLocationHistory = (0, _element.useRef)([]);
  const [screens, dispatch] = (0, _element.useReducer)(screensReducer, []);
  const currentScreens = (0, _element.useRef)([]);
  (0, _element.useEffect)(() => {
    currentScreens.current = screens;
  }, [screens]);
  (0, _element.useEffect)(() => {
    currentLocationHistory.current = locationHistory;
  }, [locationHistory]);
  const currentMatch = (0, _element.useRef)();
  const matchedPath = (0, _element.useMemo)(() => {
    let currentPath;
    if (locationHistory.length === 0 || (currentPath = locationHistory[locationHistory.length - 1].path) === undefined) {
      currentMatch.current = undefined;
      return undefined;
    }
    const resolvePath = path => {
      const newMatch = (0, _router.patternMatch)(path, screens);

      // If the new match is the same as the current match,
      // return the previous one for performance reasons.
      if (currentMatch.current && newMatch && (0, _isShallowEqual.default)(newMatch.params, currentMatch.current.params) && newMatch.id === currentMatch.current.id) {
        return currentMatch.current;
      }
      return newMatch;
    };
    const newMatch = resolvePath(currentPath);
    currentMatch.current = newMatch;
    return newMatch;
  }, [screens, locationHistory]);
  const addScreen = (0, _element.useCallback)(screen => dispatch({
    type: 'add',
    screen
  }), []);
  const removeScreen = (0, _element.useCallback)(screen => dispatch({
    type: 'remove',
    screen
  }), []);
  const goBack = (0, _element.useCallback)(() => {
    setLocationHistory(prevLocationHistory => {
      if (prevLocationHistory.length <= 1) {
        return prevLocationHistory;
      }
      return [...prevLocationHistory.slice(0, -2), {
        ...prevLocationHistory[prevLocationHistory.length - 2],
        isBack: true,
        hasRestoredFocus: false
      }];
    });
  }, []);
  const goTo = (0, _element.useCallback)((path, options = {}) => {
    const {
      focusTargetSelector,
      isBack = false,
      skipFocus = false,
      replace = false,
      ...restOptions
    } = options;
    const isNavigatingToPreviousPath = isBack && currentLocationHistory.current.length > 1 && currentLocationHistory.current[currentLocationHistory.current.length - 2].path === path;
    if (isNavigatingToPreviousPath) {
      goBack();
      return;
    }
    setLocationHistory(prevLocationHistory => {
      const newLocation = {
        ...restOptions,
        path,
        isBack,
        hasRestoredFocus: false,
        skipFocus
      };
      if (prevLocationHistory.length === 0) {
        return replace ? [] : [newLocation];
      }
      const newLocationHistory = prevLocationHistory.slice(prevLocationHistory.length > MAX_HISTORY_LENGTH - 1 ? 1 : 0, -1);
      if (!replace) {
        newLocationHistory.push(
        // Assign `focusTargetSelector` to the previous location in history
        // (the one we just navigated from).
        {
          ...prevLocationHistory[prevLocationHistory.length - 1],
          focusTargetSelector
        });
      }
      newLocationHistory.push(newLocation);
      return newLocationHistory;
    });
  }, [goBack]);
  const goToParent = (0, _element.useCallback)((options = {}) => {
    const currentPath = currentLocationHistory.current[currentLocationHistory.current.length - 1].path;
    if (currentPath === undefined) {
      return;
    }
    const parentPath = (0, _router.findParent)(currentPath, currentScreens.current);
    if (parentPath === undefined) {
      return;
    }
    goTo(parentPath, {
      ...options,
      isBack: true
    });
  }, [goTo]);
  const navigatorContextValue = (0, _element.useMemo)(() => ({
    location: {
      ...locationHistory[locationHistory.length - 1],
      isInitial: locationHistory.length === 1
    },
    params: matchedPath ? matchedPath.params : {},
    match: matchedPath ? matchedPath.id : undefined,
    goTo,
    goBack,
    goToParent,
    addScreen,
    removeScreen
  }), [locationHistory, matchedPath, goTo, goBack, goToParent, addScreen, removeScreen]);
  const cx = (0, _useCx.useCx)();
  const classes = (0, _element.useMemo)(() => cx(styles.navigatorProviderWrapper, className), [className, cx]);
  return (0, _react.createElement)(_view.View, {
    ref: forwardedRef,
    className: classes,
    ...otherProps
  }, (0, _react.createElement)(_context2.NavigatorContext.Provider, {
    value: navigatorContextValue
  }, children));
}

/**
 * The `NavigatorProvider` component allows rendering nested views/panels/menus
 * (via the `NavigatorScreen` component and navigate between these different
 * view (via the `NavigatorButton` and `NavigatorBackButton` components or the
 * `useNavigator` hook).
 *
 * ```jsx
 * import {
 *   __experimentalNavigatorProvider as NavigatorProvider,
 *   __experimentalNavigatorScreen as NavigatorScreen,
 *   __experimentalNavigatorButton as NavigatorButton,
 *   __experimentalNavigatorBackButton as NavigatorBackButton,
 * } from '@wordpress/components';
 *
 * const MyNavigation = () => (
 *   <NavigatorProvider initialPath="/">
 *     <NavigatorScreen path="/">
 *       <p>This is the home screen.</p>
 *        <NavigatorButton path="/child">
 *          Navigate to child screen.
 *       </NavigatorButton>
 *     </NavigatorScreen>
 *
 *     <NavigatorScreen path="/child">
 *       <p>This is the child screen.</p>
 *       <NavigatorBackButton>
 *         Go back
 *       </NavigatorBackButton>
 *     </NavigatorScreen>
 *   </NavigatorProvider>
 * );
 * ```
 */
const NavigatorProvider = exports.NavigatorProvider = (0, _context.contextConnect)(UnconnectedNavigatorProvider, 'NavigatorProvider');
var _default = exports.default = NavigatorProvider;
//# sourceMappingURL=component.js.map