"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addAttribute = addAttribute;
exports.default = void 0;
exports.useLayoutClasses = useLayoutClasses;
exports.useLayoutStyles = useLayoutStyles;
exports.withLayoutStyles = void 0;
var _react = require("react");
var _classnames = _interopRequireDefault(require("classnames"));
var _compose = require("@wordpress/compose");
var _hooks = require("@wordpress/hooks");
var _blocks = require("@wordpress/blocks");
var _data = require("@wordpress/data");
var _components = require("@wordpress/components");
var _i18n = require("@wordpress/i18n");
var _store = require("../store");
var _components2 = require("../components");
var _useSettings = require("../components/use-settings");
var _layouts = require("../layouts");
var _blockEditingMode = require("../components/block-editing-mode");
var _definitions = require("../layouts/definitions");
var _utils = require("./utils");
var _lockUnlock = require("../lock-unlock");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

const layoutBlockSupportKey = 'layout';
function hasLayoutBlockSupport(blockName) {
  return (0, _blocks.hasBlockSupport)(blockName, 'layout') || (0, _blocks.hasBlockSupport)(blockName, '__experimentalLayout');
}

/**
 * Generates the utility classnames for the given block's layout attributes.
 *
 * @param { Object } blockAttributes Block attributes.
 * @param { string } blockName       Block name.
 *
 * @return { Array } Array of CSS classname strings.
 */
function useLayoutClasses(blockAttributes = {}, blockName = '') {
  const {
    kebabCase
  } = (0, _lockUnlock.unlock)(_components.privateApis);
  const rootPaddingAlignment = (0, _data.useSelect)(select => {
    const {
      getSettings
    } = select(_store.store);
    return getSettings().__experimentalFeatures?.useRootPaddingAwareAlignments;
  }, []);
  const {
    layout
  } = blockAttributes;
  const {
    default: defaultBlockLayout
  } = (0, _blocks.getBlockSupport)(blockName, layoutBlockSupportKey) || {};
  const usedLayout = layout?.inherit || layout?.contentSize || layout?.wideSize ? {
    ...layout,
    type: 'constrained'
  } : layout || defaultBlockLayout || {};
  const layoutClassnames = [];
  if (_definitions.LAYOUT_DEFINITIONS[usedLayout?.type || 'default']?.className) {
    const baseClassName = _definitions.LAYOUT_DEFINITIONS[usedLayout?.type || 'default']?.className;
    const splitBlockName = blockName.split('/');
    const fullBlockName = splitBlockName[0] === 'core' ? splitBlockName.pop() : splitBlockName.join('-');
    const compoundClassName = `wp-block-${fullBlockName}-${baseClassName}`;
    layoutClassnames.push(baseClassName, compoundClassName);
  }
  if ((usedLayout?.inherit || usedLayout?.contentSize || usedLayout?.type === 'constrained') && rootPaddingAlignment) {
    layoutClassnames.push('has-global-padding');
  }
  if (usedLayout?.orientation) {
    layoutClassnames.push(`is-${kebabCase(usedLayout.orientation)}`);
  }
  if (usedLayout?.justifyContent) {
    layoutClassnames.push(`is-content-justification-${kebabCase(usedLayout.justifyContent)}`);
  }
  if (usedLayout?.flexWrap && usedLayout.flexWrap === 'nowrap') {
    layoutClassnames.push('is-nowrap');
  }
  return layoutClassnames;
}

/**
 * Generates a CSS rule with the given block's layout styles.
 *
 * @param { Object } blockAttributes Block attributes.
 * @param { string } blockName       Block name.
 * @param { string } selector        A selector to use in generating the CSS rule.
 *
 * @return { string } CSS rule.
 */
function useLayoutStyles(blockAttributes = {}, blockName, selector) {
  const {
    layout = {},
    style = {}
  } = blockAttributes;
  // Update type for blocks using legacy layouts.
  const usedLayout = layout?.inherit || layout?.contentSize || layout?.wideSize ? {
    ...layout,
    type: 'constrained'
  } : layout || {};
  const fullLayoutType = (0, _layouts.getLayoutType)(usedLayout?.type || 'default');
  const [blockGapSupport] = (0, _useSettings.useSettings)('spacing.blockGap');
  const hasBlockGapSupport = blockGapSupport !== null;
  const css = fullLayoutType?.getLayoutStyle?.({
    blockName,
    selector,
    layout,
    style,
    hasBlockGapSupport
  });
  return css;
}
function LayoutPanelPure({
  layout,
  setAttributes,
  name: blockName,
  clientId
}) {
  const settings = (0, _utils.useBlockSettings)(blockName);
  // Block settings come from theme.json under settings.[blockName].
  const {
    layout: layoutSettings
  } = settings;
  // Layout comes from block attributes.
  const [defaultThemeLayout] = (0, _useSettings.useSettings)('layout');
  const {
    themeSupportsLayout
  } = (0, _data.useSelect)(select => {
    const {
      getSettings
    } = select(_store.store);
    return {
      themeSupportsLayout: getSettings().supportsLayout
    };
  }, []);
  const blockEditingMode = (0, _blockEditingMode.useBlockEditingMode)();
  if (blockEditingMode !== 'default') {
    return null;
  }

  // Layout block support comes from the block's block.json.
  const layoutBlockSupport = (0, _blocks.getBlockSupport)(blockName, layoutBlockSupportKey, {});
  const blockSupportAndThemeSettings = {
    ...layoutSettings,
    ...layoutBlockSupport
  };
  const {
    allowSwitching,
    allowEditing = true,
    allowInheriting = true,
    default: defaultBlockLayout
  } = blockSupportAndThemeSettings;
  if (!allowEditing) {
    return null;
  }

  // Only show the inherit toggle if it's supported,
  // a default theme layout is set (e.g. one that provides `contentSize` and/or `wideSize` values),
  // and either the default / flow or the constrained layout type is in use, as the toggle switches from one to the other.
  const showInheritToggle = !!(allowInheriting && !!defaultThemeLayout && (!layout?.type || layout?.type === 'default' || layout?.type === 'constrained' || layout?.inherit));
  const usedLayout = layout || defaultBlockLayout || {};
  const {
    inherit = false,
    type = 'default',
    contentSize = null
  } = usedLayout;
  /**
   * `themeSupportsLayout` is only relevant to the `default/flow` or
   * `constrained` layouts and it should not be taken into account when other
   * `layout` types are used.
   */
  if ((type === 'default' || type === 'constrained') && !themeSupportsLayout) {
    return null;
  }
  const layoutType = (0, _layouts.getLayoutType)(type);
  const constrainedType = (0, _layouts.getLayoutType)('constrained');
  const displayControlsForLegacyLayouts = !usedLayout.type && (contentSize || inherit);
  const hasContentSizeOrLegacySettings = !!inherit || !!contentSize;
  const onChangeType = newType => setAttributes({
    layout: {
      type: newType
    }
  });
  const onChangeLayout = newLayout => setAttributes({
    layout: newLayout
  });
  return (0, _react.createElement)(_react.Fragment, null, (0, _react.createElement)(_components2.InspectorControls, null, (0, _react.createElement)(_components.PanelBody, {
    title: (0, _i18n.__)('Layout')
  }, showInheritToggle && (0, _react.createElement)(_react.Fragment, null, (0, _react.createElement)(_components.ToggleControl, {
    __nextHasNoMarginBottom: true,
    className: "block-editor-hooks__toggle-control",
    label: (0, _i18n.__)('Inner blocks use content width'),
    checked: layoutType?.name === 'constrained' || hasContentSizeOrLegacySettings,
    onChange: () => setAttributes({
      layout: {
        type: layoutType?.name === 'constrained' || hasContentSizeOrLegacySettings ? 'default' : 'constrained'
      }
    }),
    help: layoutType?.name === 'constrained' || hasContentSizeOrLegacySettings ? (0, _i18n.__)('Nested blocks use content width with options for full and wide widths.') : (0, _i18n.__)('Nested blocks will fill the width of this container. Toggle to constrain.')
  })), !inherit && allowSwitching && (0, _react.createElement)(LayoutTypeSwitcher, {
    type: type,
    onChange: onChangeType
  }), layoutType && layoutType.name !== 'default' && (0, _react.createElement)(layoutType.inspectorControls, {
    layout: usedLayout,
    onChange: onChangeLayout,
    layoutBlockSupport: blockSupportAndThemeSettings,
    name: blockName,
    clientId: clientId
  }), constrainedType && displayControlsForLegacyLayouts && (0, _react.createElement)(constrainedType.inspectorControls, {
    layout: usedLayout,
    onChange: onChangeLayout,
    layoutBlockSupport: blockSupportAndThemeSettings,
    name: blockName,
    clientId: clientId
  }))), !inherit && layoutType && (0, _react.createElement)(layoutType.toolBarControls, {
    layout: usedLayout,
    onChange: onChangeLayout,
    layoutBlockSupport: layoutBlockSupport,
    name: blockName,
    clientId: clientId
  }));
}
var _default = exports.default = {
  shareWithChildBlocks: true,
  edit: LayoutPanelPure,
  attributeKeys: ['layout'],
  hasSupport(name) {
    return hasLayoutBlockSupport(name);
  }
};
function LayoutTypeSwitcher({
  type,
  onChange
}) {
  return (0, _react.createElement)(_components.ButtonGroup, null, (0, _layouts.getLayoutTypes)().map(({
    name,
    label
  }) => {
    return (0, _react.createElement)(_components.Button, {
      key: name,
      isPressed: type === name,
      onClick: () => onChange(name)
    }, label);
  }));
}

/**
 * Filters registered block settings, extending attributes to include `layout`.
 *
 * @param {Object} settings Original block settings.
 *
 * @return {Object} Filtered block settings.
 */
function addAttribute(settings) {
  var _settings$attributes$;
  if ('type' in ((_settings$attributes$ = settings.attributes?.layout) !== null && _settings$attributes$ !== void 0 ? _settings$attributes$ : {})) {
    return settings;
  }
  if (hasLayoutBlockSupport(settings)) {
    settings.attributes = {
      ...settings.attributes,
      layout: {
        type: 'object'
      }
    };
  }
  return settings;
}
function BlockWithLayoutStyles({
  block: BlockListBlock,
  props
}) {
  const {
    name,
    attributes
  } = props;
  const id = (0, _compose.useInstanceId)(BlockListBlock);
  const {
    layout
  } = attributes;
  const {
    default: defaultBlockLayout
  } = (0, _blocks.getBlockSupport)(name, layoutBlockSupportKey) || {};
  const usedLayout = layout?.inherit || layout?.contentSize || layout?.wideSize ? {
    ...layout,
    type: 'constrained'
  } : layout || defaultBlockLayout || {};
  const layoutClasses = useLayoutClasses(attributes, name);
  const {
    kebabCase
  } = (0, _lockUnlock.unlock)(_components.privateApis);
  const selectorPrefix = `wp-container-${kebabCase(name)}-is-layout-`;
  // Higher specificity to override defaults from theme.json.
  const selector = `.${selectorPrefix}${id}.${selectorPrefix}${id}`;
  const [blockGapSupport] = (0, _useSettings.useSettings)('spacing.blockGap');
  const hasBlockGapSupport = blockGapSupport !== null;

  // Get CSS string for the current layout type.
  // The CSS and `style` element is only output if it is not empty.
  const fullLayoutType = (0, _layouts.getLayoutType)(usedLayout?.type || 'default');
  const css = fullLayoutType?.getLayoutStyle?.({
    blockName: name,
    selector,
    layout: usedLayout,
    style: attributes?.style,
    hasBlockGapSupport
  });

  // Attach a `wp-container-` id-based class name as well as a layout class name such as `is-layout-flex`.
  const layoutClassNames = (0, _classnames.default)({
    [`${selectorPrefix}${id}`]: !!css // Only attach a container class if there is generated CSS to be attached.
  }, layoutClasses);
  (0, _utils.useStyleOverride)({
    css
  });
  return (0, _react.createElement)(BlockListBlock, {
    ...props,
    __unstableLayoutClassNames: layoutClassNames
  });
}

/**
 * Override the default block element to add the layout styles.
 *
 * @param {Function} BlockListBlock Original component.
 *
 * @return {Function} Wrapped component.
 */
const withLayoutStyles = exports.withLayoutStyles = (0, _compose.createHigherOrderComponent)(BlockListBlock => props => {
  const blockSupportsLayout = hasLayoutBlockSupport(props.name);
  const shouldRenderLayoutStyles = (0, _data.useSelect)(select => {
    // The callback returns early to avoid block editor subscription.
    if (!blockSupportsLayout) {
      return false;
    }
    return !select(_store.store).getSettings().disableLayoutStyles;
  }, [blockSupportsLayout]);
  if (!shouldRenderLayoutStyles) {
    return (0, _react.createElement)(BlockListBlock, {
      ...props
    });
  }
  return (0, _react.createElement)(BlockWithLayoutStyles, {
    block: BlockListBlock,
    props: props
  });
}, 'withLayoutStyles');
(0, _hooks.addFilter)('blocks.registerBlockType', 'core/layout/addAttribute', addAttribute);
(0, _hooks.addFilter)('editor.BlockListBlock', 'core/editor/layout/with-layout-styles', withLayoutStyles);
//# sourceMappingURL=layout.js.map