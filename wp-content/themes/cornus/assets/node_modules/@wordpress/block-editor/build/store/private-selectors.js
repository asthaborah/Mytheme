"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAllPatterns = void 0;
exports.getBlockRemovalRules = getBlockRemovalRules;
Object.defineProperty(exports, "getBlockSettings", {
  enumerable: true,
  get: function () {
    return _getBlockSettings.getBlockSettings;
  }
});
exports.getBlockWithoutAttributes = getBlockWithoutAttributes;
exports.getInserterMediaCategories = exports.getEnabledClientIdsTree = exports.getEnabledBlockParents = void 0;
exports.getLastFocus = getLastFocus;
exports.getLastInsertedBlocksClientIds = getLastInsertedBlocksClientIds;
exports.getOpenedBlockSettingsMenu = getOpenedBlockSettingsMenu;
exports.getRegisteredInserterMediaCategories = getRegisteredInserterMediaCategories;
exports.getRemovalPromptData = getRemovalPromptData;
exports.getStyleOverrides = getStyleOverrides;
exports.hasAllowedPatterns = void 0;
exports.isBlockInterfaceHidden = isBlockInterfaceHidden;
exports.isBlockSubtreeDisabled = void 0;
exports.isDragging = isDragging;
var _rememo = _interopRequireDefault(require("rememo"));
var _data = require("@wordpress/data");
var _selectors = require("./selectors");
var _utils = require("./utils");
var _utils2 = require("../components/inserter/block-patterns-tab/utils");
var _constants = require("./constants");
var _lockUnlock = require("../lock-unlock");
var _privateKeys = require("./private-keys");
var _getBlockSettings = require("./get-block-settings");
/**
 * External dependencies
 */

/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

/**
 * Returns true if the block interface is hidden, or false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether the block toolbar is hidden.
 */
function isBlockInterfaceHidden(state) {
  return state.isBlockInterfaceHidden;
}

/**
 * Gets the client ids of the last inserted blocks.
 *
 * @param {Object} state Global application state.
 * @return {Array|undefined} Client Ids of the last inserted block(s).
 */
function getLastInsertedBlocksClientIds(state) {
  return state?.lastBlockInserted?.clientIds;
}
function getBlockWithoutAttributes(state, clientId) {
  return state.blocks.byClientId.get(clientId);
}

/**
 * Returns true if all of the descendants of a block with the given client ID
 * have an editing mode of 'disabled', or false otherwise.
 *
 * @param {Object} state    Global application state.
 * @param {string} clientId The block client ID.
 *
 * @return {boolean} Whether the block descendants are disabled.
 */
const isBlockSubtreeDisabled = (state, clientId) => {
  const isChildSubtreeDisabled = childClientId => {
    return (0, _selectors.getBlockEditingMode)(state, childClientId) === 'disabled' && (0, _selectors.getBlockOrder)(state, childClientId).every(isChildSubtreeDisabled);
  };
  return (0, _selectors.getBlockOrder)(state, clientId).every(isChildSubtreeDisabled);
};
exports.isBlockSubtreeDisabled = isBlockSubtreeDisabled;
function getEnabledClientIdsTreeUnmemoized(state, rootClientId) {
  const blockOrder = (0, _selectors.getBlockOrder)(state, rootClientId);
  const result = [];
  for (const clientId of blockOrder) {
    const innerBlocks = getEnabledClientIdsTreeUnmemoized(state, clientId);
    if ((0, _selectors.getBlockEditingMode)(state, clientId) !== 'disabled') {
      result.push({
        clientId,
        innerBlocks
      });
    } else {
      result.push(...innerBlocks);
    }
  }
  return result;
}

/**
 * Returns a tree of block objects with only clientID and innerBlocks set.
 * Blocks with a 'disabled' editing mode are not included.
 *
 * @param {Object}  state        Global application state.
 * @param {?string} rootClientId Optional root client ID of block list.
 *
 * @return {Object[]} Tree of block objects with only clientID and innerBlocks set.
 */
const getEnabledClientIdsTree = exports.getEnabledClientIdsTree = (0, _rememo.default)(getEnabledClientIdsTreeUnmemoized, state => [state.blocks.order, state.blockEditingModes, state.settings.templateLock, state.blockListSettings]);

/**
 * Returns a list of a given block's ancestors, from top to bottom. Blocks with
 * a 'disabled' editing mode are excluded.
 *
 * @see getBlockParents
 *
 * @param {Object}  state     Global application state.
 * @param {string}  clientId  The block client ID.
 * @param {boolean} ascending Order results from bottom to top (true) or top
 *                            to bottom (false).
 */
const getEnabledBlockParents = exports.getEnabledBlockParents = (0, _rememo.default)((state, clientId, ascending = false) => {
  return (0, _selectors.getBlockParents)(state, clientId, ascending).filter(parent => (0, _selectors.getBlockEditingMode)(state, parent) !== 'disabled');
}, state => [state.blocks.parents, state.blockEditingModes, state.settings.templateLock, state.blockListSettings]);

/**
 * Selector that returns the data needed to display a prompt when certain
 * blocks are removed, or `false` if no such prompt is requested.
 *
 * @param {Object} state Global application state.
 *
 * @return {Object|false} Data for removal prompt display, if any.
 */
function getRemovalPromptData(state) {
  return state.removalPromptData;
}

/**
 * Returns true if removal prompt exists, or false otherwise.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether removal prompt exists.
 */
function getBlockRemovalRules(state) {
  return state.blockRemovalRules;
}

/**
 * Returns the client ID of the block settings menu that is currently open.
 *
 * @param {Object} state Global application state.
 * @return {string|null} The client ID of the block menu that is currently open.
 */
function getOpenedBlockSettingsMenu(state) {
  return state.openedBlockSettingsMenu;
}

/**
 * Returns all style overrides, intended to be merged with global editor styles.
 *
 * @param {Object} state Global application state.
 *
 * @return {Map} A map of style IDs to style overrides.
 */
function getStyleOverrides(state) {
  return state.styleOverrides;
}

/** @typedef {import('./actions').InserterMediaCategory} InserterMediaCategory */
/**
 * Returns the registered inserter media categories through the public API.
 *
 * @param {Object} state Editor state.
 *
 * @return {InserterMediaCategory[]} Inserter media categories.
 */
function getRegisteredInserterMediaCategories(state) {
  return state.registeredInserterMediaCategories;
}

/**
 * Returns an array containing the allowed inserter media categories.
 * It merges the registered media categories from extenders with the
 * core ones. It also takes into account the allowed `mime_types`, which
 * can be altered by `upload_mimes` filter and restrict some of them.
 *
 * @param {Object} state Global application state.
 *
 * @return {InserterMediaCategory[]} Client IDs of descendants.
 */
const getInserterMediaCategories = exports.getInserterMediaCategories = (0, _rememo.default)(state => {
  const {
    settings: {
      inserterMediaCategories,
      allowedMimeTypes,
      enableOpenverseMediaCategory
    },
    registeredInserterMediaCategories
  } = state;
  // The allowed `mime_types` can be altered by `upload_mimes` filter and restrict
  // some of them. In this case we shouldn't add the category to the available media
  // categories list in the inserter.
  if (!inserterMediaCategories && !registeredInserterMediaCategories.length || !allowedMimeTypes) {
    return;
  }
  const coreInserterMediaCategoriesNames = inserterMediaCategories?.map(({
    name
  }) => name) || [];
  const mergedCategories = [...(inserterMediaCategories || []), ...(registeredInserterMediaCategories || []).filter(({
    name
  }) => !coreInserterMediaCategoriesNames.includes(name))];
  return mergedCategories.filter(category => {
    // Check if Openverse category is enabled.
    if (!enableOpenverseMediaCategory && category.name === 'openverse') {
      return false;
    }
    return Object.values(allowedMimeTypes).some(mimeType => mimeType.startsWith(`${category.mediaType}/`));
  });
}, state => [state.settings.inserterMediaCategories, state.settings.allowedMimeTypes, state.settings.enableOpenverseMediaCategory, state.registeredInserterMediaCategories]);

/**
 * Returns whether there is at least one allowed pattern for inner blocks children.
 * This is useful for deferring the parsing of all patterns until needed.
 *
 * @param {Object} state               Editor state.
 * @param {string} [rootClientId=null] Target root client ID.
 *
 * @return {boolean} If there is at least one allowed pattern.
 */
const hasAllowedPatterns = exports.hasAllowedPatterns = (0, _data.createRegistrySelector)(select => (0, _rememo.default)((state, rootClientId = null) => {
  const {
    getAllPatterns,
    __experimentalGetParsedPattern
  } = (0, _lockUnlock.unlock)(select(_constants.STORE_NAME));
  const patterns = getAllPatterns();
  const {
    allowedBlockTypes
  } = (0, _selectors.getSettings)(state);
  return patterns.some(({
    name,
    inserter = true
  }) => {
    if (!inserter) {
      return false;
    }
    const {
      blocks
    } = __experimentalGetParsedPattern(name);
    return (0, _utils.checkAllowListRecursive)(blocks, allowedBlockTypes) && blocks.every(({
      name: blockName
    }) => (0, _selectors.canInsertBlockType)(state, blockName, rootClientId));
  });
}, (state, rootClientId) => [(0, _utils.getAllPatternsDependants)(select)(state), state.settings.allowedBlockTypes, state.settings.templateLock, state.blockListSettings[rootClientId], state.blocks.byClientId.get(rootClientId)]));
const getAllPatterns = exports.getAllPatterns = (0, _data.createRegistrySelector)(select => (0, _rememo.default)(state => {
  var _state$settings$selec;
  // This setting is left for back compat.
  const {
    __experimentalBlockPatterns = [],
    __experimentalUserPatternCategories = [],
    __experimentalReusableBlocks = []
  } = state.settings;
  const userPatterns = (__experimentalReusableBlocks !== null && __experimentalReusableBlocks !== void 0 ? __experimentalReusableBlocks : []).map(userPattern => {
    return {
      name: `core/block/${userPattern.id}`,
      id: userPattern.id,
      type: _utils2.INSERTER_PATTERN_TYPES.user,
      title: userPattern.title.raw,
      categories: userPattern.wp_pattern_category.map(catId => {
        const category = (__experimentalUserPatternCategories !== null && __experimentalUserPatternCategories !== void 0 ? __experimentalUserPatternCategories : []).find(({
          id
        }) => id === catId);
        return category ? category.slug : catId;
      }),
      content: userPattern.content.raw,
      syncStatus: userPattern.wp_pattern_sync_status
    };
  });
  return [...userPatterns, ...__experimentalBlockPatterns, ...((_state$settings$selec = state.settings[_privateKeys.selectBlockPatternsKey]?.(select)) !== null && _state$settings$selec !== void 0 ? _state$settings$selec : [])].filter((x, index, arr) => index === arr.findIndex(y => x.name === y.name));
}, (0, _utils.getAllPatternsDependants)(select)));

/**
 * Returns the element of the last element that had focus when focus left the editor canvas.
 *
 * @param {Object} state Block editor state.
 *
 * @return {Object} Element.
 */
function getLastFocus(state) {
  return state.lastFocus;
}

/**
 * Returns true if the user is dragging anything, or false otherwise. It is possible for a
 * user to be dragging data from outside of the editor, so this selector is separate from
 * the `isDraggingBlocks` selector which only returns true if the user is dragging blocks.
 *
 * @param {Object} state Global application state.
 *
 * @return {boolean} Whether user is dragging.
 */
function isDragging(state) {
  return state.isDragging;
}
//# sourceMappingURL=private-selectors.js.map