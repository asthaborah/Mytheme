{"version":3,"names":["_data","require","_compose","_dom","_store","useFocusHandler","clientId","isBlockSelected","useSelect","blockEditorStore","selectBlock","selectionChange","useDispatch","useRefEffect","node","onFocus","event","parentElement","closest","target","isContentEditable","isInsideRootBlock","addEventListener","removeEventListener"],"sources":["@wordpress/block-editor/src/components/block-list/use-block-props/use-focus-handler.js"],"sourcesContent":["/**\n * WordPress dependencies\n */\nimport { useSelect, useDispatch } from '@wordpress/data';\nimport { useRefEffect } from '@wordpress/compose';\n\n/**\n * Internal dependencies\n */\nimport { isInsideRootBlock } from '../../../utils/dom';\nimport { store as blockEditorStore } from '../../../store';\n\n/**\n * Selects the block if it receives focus.\n *\n * @param {string} clientId Block client ID.\n */\nexport function useFocusHandler( clientId ) {\n\tconst { isBlockSelected } = useSelect( blockEditorStore );\n\tconst { selectBlock, selectionChange } = useDispatch( blockEditorStore );\n\n\treturn useRefEffect(\n\t\t( node ) => {\n\t\t\t/**\n\t\t\t * Marks the block as selected when focused and not already\n\t\t\t * selected. This specifically handles the case where block does not\n\t\t\t * set focus on its own (via `setFocus`), typically if there is no\n\t\t\t * focusable input in the block.\n\t\t\t *\n\t\t\t * @param {FocusEvent} event Focus event.\n\t\t\t */\n\t\t\tfunction onFocus( event ) {\n\t\t\t\t// When the whole editor is editable, let writing flow handle\n\t\t\t\t// selection.\n\t\t\t\tif (\n\t\t\t\t\tnode.parentElement.closest( '[contenteditable=\"true\"]' )\n\t\t\t\t) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Check synchronously because a non-selected block might be\n\t\t\t\t// getting data through `useSelect` asynchronously.\n\t\t\t\tif ( isBlockSelected( clientId ) ) {\n\t\t\t\t\t// Potentially change selection away from rich text.\n\t\t\t\t\tif ( ! event.target.isContentEditable ) {\n\t\t\t\t\t\tselectionChange( clientId );\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If an inner block is focussed, that block is resposible for\n\t\t\t\t// setting the selected block.\n\t\t\t\tif ( ! isInsideRootBlock( node, event.target ) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tselectBlock( clientId );\n\t\t\t}\n\n\t\t\tnode.addEventListener( 'focusin', onFocus );\n\n\t\t\treturn () => {\n\t\t\t\tnode.removeEventListener( 'focusin', onFocus );\n\t\t\t};\n\t\t},\n\t\t[ isBlockSelected, selectBlock ]\n\t);\n}\n"],"mappings":";;;;;;AAGA,IAAAA,KAAA,GAAAC,OAAA;AACA,IAAAC,QAAA,GAAAD,OAAA;AAKA,IAAAE,IAAA,GAAAF,OAAA;AACA,IAAAG,MAAA,GAAAH,OAAA;AAVA;AACA;AACA;;AAIA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACO,SAASI,eAAeA,CAAEC,QAAQ,EAAG;EAC3C,MAAM;IAAEC;EAAgB,CAAC,GAAG,IAAAC,eAAS,EAAEC,YAAiB,CAAC;EACzD,MAAM;IAAEC,WAAW;IAAEC;EAAgB,CAAC,GAAG,IAAAC,iBAAW,EAAEH,YAAiB,CAAC;EAExE,OAAO,IAAAI,qBAAY,EAChBC,IAAI,IAAM;IACX;AACH;AACA;AACA;AACA;AACA;AACA;AACA;IACG,SAASC,OAAOA,CAAEC,KAAK,EAAG;MACzB;MACA;MACA,IACCF,IAAI,CAACG,aAAa,CAACC,OAAO,CAAE,0BAA2B,CAAC,EACvD;QACD;MACD;;MAEA;MACA;MACA,IAAKX,eAAe,CAAED,QAAS,CAAC,EAAG;QAClC;QACA,IAAK,CAAEU,KAAK,CAACG,MAAM,CAACC,iBAAiB,EAAG;UACvCT,eAAe,CAAEL,QAAS,CAAC;QAC5B;QACA;MACD;;MAEA;MACA;MACA,IAAK,CAAE,IAAAe,sBAAiB,EAAEP,IAAI,EAAEE,KAAK,CAACG,MAAO,CAAC,EAAG;QAChD;MACD;MAEAT,WAAW,CAAEJ,QAAS,CAAC;IACxB;IAEAQ,IAAI,CAACQ,gBAAgB,CAAE,SAAS,EAAEP,OAAQ,CAAC;IAE3C,OAAO,MAAM;MACZD,IAAI,CAACS,mBAAmB,CAAE,SAAS,EAAER,OAAQ,CAAC;IAC/C,CAAC;EACF,CAAC,EACD,CAAER,eAAe,EAAEG,WAAW,CAC/B,CAAC;AACF"}