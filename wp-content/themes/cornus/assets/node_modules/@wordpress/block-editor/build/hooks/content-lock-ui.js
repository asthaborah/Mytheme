"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = require("react");
var _components = require("@wordpress/components");
var _data = require("@wordpress/data");
var _i18n = require("@wordpress/i18n");
var _element = require("@wordpress/element");
var _store = require("../store");
var _components2 = require("../components");
var _lockUnlock = require("../lock-unlock");
/**
 * WordPress dependencies
 */

/**
 * Internal dependencies
 */

// The implementation of content locking is mainly in this file, although the mechanism
// to stop temporarily editing as blocks when an outside block is selected is on component StopEditingAsBlocksOnOutsideSelect
// at block-editor/src/components/block-list/index.js.
// Besides the components on this file and the file referenced above the implementation
// also includes artifacts on the store (actions, reducers, and selector).

function ContentLockControlsPure({
  clientId,
  isSelected
}) {
  const {
    getBlockListSettings,
    getSettings
  } = (0, _data.useSelect)(_store.store);
  const {
    templateLock,
    isLockedByParent,
    isEditingAsBlocks
  } = (0, _data.useSelect)(select => {
    const {
      __unstableGetContentLockingParent,
      getTemplateLock,
      __unstableGetTemporarilyEditingAsBlocks
    } = select(_store.store);
    return {
      templateLock: getTemplateLock(clientId),
      isLockedByParent: !!__unstableGetContentLockingParent(clientId),
      isEditingAsBlocks: __unstableGetTemporarilyEditingAsBlocks() === clientId
    };
  }, [clientId]);
  const {
    updateSettings,
    updateBlockListSettings,
    __unstableSetTemporarilyEditingAsBlocks
  } = (0, _data.useDispatch)(_store.store);
  const {
    stopEditingAsBlocks
  } = (0, _lockUnlock.unlock)((0, _data.useDispatch)(_store.store));
  const isContentLocked = !isLockedByParent && templateLock === 'contentOnly';
  const {
    __unstableMarkNextChangeAsNotPersistent,
    updateBlockAttributes
  } = (0, _data.useDispatch)(_store.store);
  const stopEditingAsBlockCallback = (0, _element.useCallback)(() => {
    stopEditingAsBlocks(clientId);
  }, [clientId, stopEditingAsBlocks]);
  if (!isContentLocked && !isEditingAsBlocks) {
    return null;
  }
  const showStopEditingAsBlocks = isEditingAsBlocks && !isContentLocked;
  const showStartEditingAsBlocks = !isEditingAsBlocks && isContentLocked && isSelected;
  return (0, _react.createElement)(_react.Fragment, null, showStopEditingAsBlocks && (0, _react.createElement)(_react.Fragment, null, (0, _react.createElement)(_components2.BlockControls, {
    group: "other"
  }, (0, _react.createElement)(_components.ToolbarButton, {
    onClick: stopEditingAsBlockCallback
  }, (0, _i18n.__)('Done')))), showStartEditingAsBlocks && (0, _react.createElement)(_components2.BlockSettingsMenuControls, null, ({
    onClose
  }) => (0, _react.createElement)(_components.MenuItem, {
    onClick: () => {
      __unstableMarkNextChangeAsNotPersistent();
      updateBlockAttributes(clientId, {
        templateLock: undefined
      });
      updateBlockListSettings(clientId, {
        ...getBlockListSettings(clientId),
        templateLock: false
      });
      const focusModeToRevert = getSettings().focusMode;
      updateSettings({
        focusMode: true
      });
      __unstableSetTemporarilyEditingAsBlocks(clientId, focusModeToRevert);
      onClose();
    }
  }, (0, _i18n.__)('Modify'))));
}
var _default = exports.default = {
  edit: ContentLockControlsPure,
  hasSupport() {
    return true;
  }
};
//# sourceMappingURL=content-lock-ui.js.map